THERE_BE_DRAGONS_HERE
CollectionIsEmpty: an OrderedCollection() is empty
24 February 2023 6:17:37.473 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.536.sha.2314c3f457171dcde477ff6575b578835f1fd519 (64 Bit)]

OrderedCollection(Collection)>>errorEmptyCollection
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	27
		lastIndex: 	26


OrderedCollection(Collection)>>emptyCheck
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	27
		lastIndex: 	26


OrderedCollection>>removeFirst
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		firstObject: 	nil
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	27
		lastIndex: 	26


War class>>deal:
	Receiver: War
	Arguments and temporary variables: 
		aDeck: 	#(1 1 1 1 13 13 13 13 11 11 11 11 12 12 12 12 10 10 10 10 9 9 9 9 7 7 7 ...etc...
		currentCard1: 	14
		currentCard2: 	14
		sortedCards: 	a SortedCollection(14 14 14 14 13 13 13 13 12 12 12 12 11 11 11 11...etc...
		pile1: 	an OrderedCollection()
		pile2: 	an OrderedCollection(14 14 14 14 13 13 13 13 12 12 12 12 11 11 11 11 10 ...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#War
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#WAR


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		tests: 	#(#(1 1 1 1 13 13 13 13 11 11 11 11 12 12 12 12 10 10 10 10 9 9 9 9 7 7 ...etc...
		results: 	#(#(1 1 1 1 13 13 13 13 12 12 12 12 11 11 11 11 10 10 10 10 9 9 9 9 8 ...etc...
		i: 	1
		shuffling: 	#(1 1 1 1 13 13 13 13 11 11 11 11 12 12 12 12 10 10 10 10 9 9 9 9 7 ...etc...
		should_be: 	#(1 1 1 1 13 13 13 13 12 12 12 12 11 11 11 11 10 10 10 10 9 9 9 9 8 ...etc...
		you_said: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| tests results |
	"
These test cases assume that the TOP of the de...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| tests results |
	"
These test cases assume that the TOP of the de...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'| tests results |

"
These test cases assume that the TOP of the deck...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 2326) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| tests results |

"
These test cases assume t...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'| tests results |

"
These test cases assume that the TOP of the deck...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 2326) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| tests results |

"
These test cases assume t...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand name...etc...
		startpc: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(72545792))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(72545792)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		event: 	[(21.0@19.0) mouseUp 1274202 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		evt: 	[(21.0@19.0) mouseUp 1274202 nil]
		all: 	an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216)...etc...
		m: 	a SpToolbarButtonMorph(72545792)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216) a SpToolbarButt...etc...
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216) a SpToolbarButt...etc...

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		evt: 	[(21.0@19.0) mouseUp 1274202 nil]
		all: 	an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216)...etc...
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(21.0@19.0) mouseUp 1274202 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(21.0@19.0) mouseUp 1274202 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(72545792)
	Receiver's instance variables: 
		timeStamp: 	1274202
		source: 	a HandMorph(284116480)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(21.0@19.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(21.0@19.0) mouseUp 1274202 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(21.0@19.0) mouseUp 1274202 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(950@96) mouseUp 1274202 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(1048330240) [world]
		transformedEvent: 	[(21.0@19.0) mouseUp 1274202 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(950@96) corner: (966@112)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(950@96) corner: (966@112)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(950@96) mouseUp 1274202 nil]
		targetOffset: 	(21.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(284116480)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(1048330240) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a Fading...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(950@96) mouseUp 1274202 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(1048330240) [world]
		transformedEvent: 	[(21.0@19.0) mouseUp 1274202 nil]
	Receiver's instance variables: 
		bounds: 	(950@96) corner: (966@112)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(950@96) corner: (966@112)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(950@96) mouseUp 1274202 nil]
		targetOffset: 	(21.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(950@96) mouseUp 1274202 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(950@96) corner: (966@112)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(950@96) corner: (966@112)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(950@96) mouseUp 1274202 nil]
		targetOffset: 	(21.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(950@96) mouseUp 1274202 nil]
	Receiver's instance variables: 
		bounds: 	(950@96) corner: (966@112)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(950@96) corner: (966@112)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(950@96) mouseUp 1274202 nil]
		targetOffset: 	(21.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(950@96) mouseUp 1274202 nil]
		evt: 	[(950@96) mouseUp 1274202 nil]
	Receiver's instance variables: 
		bounds: 	(950@96) corner: (966@112)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(950@96) corner: (966@112)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(950@96) mouseUp 1274202 nil]
		targetOffset: 	(21.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(950@96) mouseUp 1274202 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(1048330240) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(1048330240) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(284116480))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a FadingMorph(798520576))(a FadingMorp...etc...
		lastStepTime: 	1274197
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	1274197
		activeHand: 	a HandMorph(284116480)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1536@841)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a Fading...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(1048330240) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(284116480))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a FadingMorph(798520576))(a FadingMorp...etc...
		lastStepTime: 	1274197
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	1274197
		activeHand: 	a HandMorph(284116480)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1536@841)


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a Fading...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a Fading...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorEmptyCollection
OrderedCollection(Collection)>>emptyCheck
OrderedCollection>>removeFirst
War class>>deal:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
CollectionIsEmpty: an OrderedCollection() is empty
24 February 2023 6:17:37.767 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.536.sha.2314c3f457171dcde477ff6575b578835f1fd519 (64 Bit)]

OrderedCollection(Collection)>>errorEmptyCollection
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	27
		lastIndex: 	26


OrderedCollection(Collection)>>emptyCheck
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	27
		lastIndex: 	26


OrderedCollection>>removeFirst
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		firstObject: 	nil
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	27
		lastIndex: 	26


War class>>deal:
	Receiver: War
	Arguments and temporary variables: 
		aDeck: 	#(1 1 1 1 13 13 13 13 11 11 11 11 12 12 12 12 10 10 10 10 9 9 9 9 7 7 7 ...etc...
		currentCard1: 	14
		currentCard2: 	14
		sortedCards: 	a SortedCollection(14 14 14 14 13 13 13 13 12 12 12 12 11 11 11 11...etc...
		pile1: 	an OrderedCollection()
		pile2: 	an OrderedCollection(14 14 14 14 13 13 13 13 12 12 12 12 11 11 11 11 10 ...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#War
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#WAR


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		tests: 	#(#(1 1 1 1 13 13 13 13 11 11 11 11 12 12 12 12 10 10 10 10 9 9 9 9 7 7 ...etc...
		results: 	#(#(1 1 1 1 13 13 13 13 12 12 12 12 11 11 11 11 10 10 10 10 9 9 9 9 8 ...etc...
		i: 	1
		shuffling: 	#(1 1 1 1 13 13 13 13 11 11 11 11 12 12 12 12 10 10 10 10 9 9 9 9 7 ...etc...
		should_be: 	#(1 1 1 1 13 13 13 13 12 12 12 12 11 11 11 11 10 10 10 10 9 9 9 9 8 ...etc...
		you_said: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| tests results |
	"
These test cases assume that the TOP of the de...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| tests results |
	"
These test cases assume that the TOP of the de...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'| tests results |

"
These test cases assume that the TOP of the deck...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 2326) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| tests results |

"
These test cases assume t...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'| tests results |

"
These test cases assume that the TOP of the deck...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 2326) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| tests results |

"
These test cases assume t...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand descripError printing the compiledBlock in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand name...etc...
		startpc: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(72545792))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(72545792)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		event: 	[(21.0@19.0) mouseUp 1274202 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		evt: 	[(21.0@19.0) mouseUp 1274202 nil]
		all: 	an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216)...etc...
		m: 	a SpToolbarButtonMorph(72545792)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216) a SpToolbarButt...etc...
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216) a SpToolbarButt...etc...

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		evt: 	[(21.0@19.0) mouseUp 1274202 nil]
		all: 	an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216)...etc...
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(21.0@19.0) mouseUp 1274202 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(21.0@19.0) mouseUp 1274202 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(72545792)
	Receiver's instance variables: 
		timeStamp: 	1274202
		source: 	a HandMorph(284116480)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(21.0@19.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(21.0@19.0) mouseUp 1274202 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(21.0@19.0) mouseUp 1274202 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(950@96) mouseUp 1274202 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(1048330240) [world]
		transformedEvent: 	[(21.0@19.0) mouseUp 1274202 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(950@96) corner: (966@112)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(950@96) corner: (966@112)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(950@96) mouseUp 1274202 nil]
		targetOffset: 	(21.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(284116480)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(1048330240) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a Fading...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(950@96) mouseUp 1274202 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(1048330240) [world]
		transformedEvent: 	[(21.0@19.0) mouseUp 1274202 nil]
	Receiver's instance variables: 
		bounds: 	(950@96) corner: (966@112)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(950@96) corner: (966@112)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(950@96) mouseUp 1274202 nil]
		targetOffset: 	(21.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(950@96) mouseUp 1274202 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(950@96) corner: (966@112)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(950@96) corner: (966@112)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(950@96) mouseUp 1274202 nil]
		targetOffset: 	(21.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(950@96) mouseUp 1274202 nil]
	Receiver's instance variables: 
		bounds: 	(950@96) corner: (966@112)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(950@96) corner: (966@112)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(950@96) mouseUp 1274202 nil]
		targetOffset: 	(21.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(950@96) mouseUp 1274202 nil]
		evt: 	[(950@96) mouseUp 1274202 nil]
	Receiver's instance variables: 
		bounds: 	(950@96) corner: (966@112)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(950@96) corner: (966@112)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(950@96) mouseUp 1274202 nil]
		targetOffset: 	(21.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(950@96) mouseUp 1274202 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(1048330240) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(1048330240) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(284116480))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a FadingMorph(798520576))(a FadingMorp...etc...
		lastStepTime: 	1274197
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	1274197
		activeHand: 	a HandMorph(284116480)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1536@841)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a Fading...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(1048330240) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(284116480))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a FadingMorph(798520576))(a FadingMorp...etc...
		lastStepTime: 	1274197
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	1274197
		activeHand: 	a HandMorph(284116480)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1536@841)


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a Fading...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a Fading...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorEmptyCollection
OrderedCollection(Collection)>>emptyCheck
OrderedCollection>>removeFirst
War class>>deal:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
CollectionIsEmpty: an OrderedCollection() is empty
24 February 2023 6:23:35.796 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.536.sha.2314c3f457171dcde477ff6575b578835f1fd519 (64 Bit)]

OrderedCollection(Collection)>>errorEmptyCollection
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	27
		lastIndex: 	26


OrderedCollection(Collection)>>emptyCheck
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	27
		lastIndex: 	26


OrderedCollection>>removeFirst
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		firstObject: 	nil
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	27
		lastIndex: 	26


War class>>deal:
	Receiver: War
	Arguments and temporary variables: 
		aDeck: 	#(1 1 1 1 13 13 13 13 11 11 11 11 12 12 12 12 10 10 10 10 9 9 9 9 7 7 7 ...etc...
		currentCard1: 	14
		currentCard2: 	14
		sortedCards: 	a SortedCollection(14 14 14 14 13 13 13 13 12 12 12 12 11 11 11 11...etc...
		pile1: 	an OrderedCollection()
		pile2: 	an OrderedCollection(14 14 14 14 13 13 13 13 12 12 12 12 11 11 11 11 10 ...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#War
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#WAR


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		tests: 	#(#(1 1 1 1 13 13 13 13 11 11 11 11 12 12 12 12 10 10 10 10 9 9 9 9 7 7 ...etc...
		results: 	#(#(1 1 1 1 13 13 13 13 12 12 12 12 11 11 11 11 10 10 10 10 9 9 9 9 8 ...etc...
		i: 	1
		shuffling: 	#(1 1 1 1 13 13 13 13 11 11 11 11 12 12 12 12 10 10 10 10 9 9 9 9 7 ...etc...
		should_be: 	#(1 1 1 1 13 13 13 13 12 12 12 12 11 11 11 11 10 10 10 10 9 9 9 9 8 ...etc...
		you_said: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| tests results |
	"
These test cases assume that the TOP of the de...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| tests results |
	"
These test cases assume that the TOP of the de...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'| tests results |

"
These test cases assume that the TOP of the deck...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 2326) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| tests results |

"
These test cases assume t...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'| tests results |

"
These test cases assume that the TOP of the deck...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 2326) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| tests results |

"
These test cases assume t...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand name...etc...
		startpc: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(72545792))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(72545792)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		event: 	[(20.0@23.0) mouseUp 1632573 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		evt: 	[(20.0@23.0) mouseUp 1632573 nil]
		all: 	an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216)...etc...
		m: 	a SpToolbarButtonMorph(72545792)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216) a SpToolbarButt...etc...
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216) a SpToolbarButt...etc...

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		evt: 	[(20.0@23.0) mouseUp 1632573 nil]
		all: 	an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216)...etc...
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(20.0@23.0) mouseUp 1632573 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(20.0@23.0) mouseUp 1632573 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(72545792)
	Receiver's instance variables: 
		timeStamp: 	1632573
		source: 	a HandMorph(284116480)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(20.0@23.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(20.0@23.0) mouseUp 1632573 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(20.0@23.0) mouseUp 1632573 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(854@121) mouseUp 1632573 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(1048330240) [world]
		transformedEvent: 	[(20.0@23.0) mouseUp 1632573 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(854@121) corner: (870@137)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(854@121) corner: (870@137)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(854@121) mouseUp 1632573 nil]
		targetOffset: 	(20.0@18.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(284116480)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(1048330240) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(854@121) mouseUp 1632573 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(1048330240) [world]
		transformedEvent: 	[(20.0@23.0) mouseUp 1632573 nil]
	Receiver's instance variables: 
		bounds: 	(854@121) corner: (870@137)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(854@121) corner: (870@137)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(854@121) mouseUp 1632573 nil]
		targetOffset: 	(20.0@18.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(854@121) mouseUp 1632573 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(854@121) corner: (870@137)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(854@121) corner: (870@137)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(854@121) mouseUp 1632573 nil]
		targetOffset: 	(20.0@18.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(854@121) mouseUp 1632573 nil]
	Receiver's instance variables: 
		bounds: 	(854@121) corner: (870@137)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(854@121) corner: (870@137)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(854@121) mouseUp 1632573 nil]
		targetOffset: 	(20.0@18.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(854@121) mouseUp 1632573 nil]
		evt: 	[(854@121) mouseUp 1632573 nil]
	Receiver's instance variables: 
		bounds: 	(854@121) corner: (870@137)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(854@121) corner: (870@137)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(854@121) mouseUp 1632573 nil]
		targetOffset: 	(20.0@18.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(854@121) mouseUp 1632573 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(1048330240) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(1048330240) [world]
		queue: 	WaitfreeQueue with 1 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(284116480))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a FadingMorph(761264640))(a FadingMorp...etc...
		lastStepTime: 	1632565
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(827456000)))
		lastAlarmTime: 	1632565
		activeHand: 	a HandMorph(284116480)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1536@841)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(1048330240) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(284116480))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a FadingMorph(761264640))(a FadingMorp...etc...
		lastStepTime: 	1632565
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(827456000)))
		lastAlarmTime: 	1632565
		activeHand: 	a HandMorph(284116480)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1536@841)


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorEmptyCollection
OrderedCollection(Collection)>>emptyCheck
OrderedCollection>>removeFirst
War class>>deal:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
CollectionIsEmpty: an OrderedCollection() is empty
24 February 2023 6:23:36.072 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.536.sha.2314c3f457171dcde477ff6575b578835f1fd519 (64 Bit)]

OrderedCollection(Collection)>>errorEmptyCollection
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	27
		lastIndex: 	26


OrderedCollection(Collection)>>emptyCheck
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	27
		lastIndex: 	26


OrderedCollection>>removeFirst
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		firstObject: 	nil
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	27
		lastIndex: 	26


War class>>deal:
	Receiver: War
	Arguments and temporary variables: 
		aDeck: 	#(1 1 1 1 13 13 13 13 11 11 11 11 12 12 12 12 10 10 10 10 9 9 9 9 7 7 7 ...etc...
		currentCard1: 	14
		currentCard2: 	14
		sortedCards: 	a SortedCollection(14 14 14 14 13 13 13 13 12 12 12 12 11 11 11 11...etc...
		pile1: 	an OrderedCollection()
		pile2: 	an OrderedCollection(14 14 14 14 13 13 13 13 12 12 12 12 11 11 11 11 10 ...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#War
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#WAR


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		tests: 	#(#(1 1 1 1 13 13 13 13 11 11 11 11 12 12 12 12 10 10 10 10 9 9 9 9 7 7 ...etc...
		results: 	#(#(1 1 1 1 13 13 13 13 12 12 12 12 11 11 11 11 10 10 10 10 9 9 9 9 8 ...etc...
		i: 	1
		shuffling: 	#(1 1 1 1 13 13 13 13 11 11 11 11 12 12 12 12 10 10 10 10 9 9 9 9 7 ...etc...
		should_be: 	#(1 1 1 1 13 13 13 13 12 12 12 12 11 11 11 11 10 10 10 10 9 9 9 9 8 ...etc...
		you_said: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| tests results |
	"
These test cases assume that the TOP of the de...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| tests results |
	"
These test cases assume that the TOP of the de...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'| tests results |

"
These test cases assume that the TOP of the deck...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 2326) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| tests results |

"
These test cases assume t...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'| tests results |

"
These test cases assume that the TOP of the deck...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 2326) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| tests results |

"
These test cases assume t...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ fal<<error during printing>>

StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand name...etc...
		startpc: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(72545792))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(72545792)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		event: 	[(20.0@23.0) mouseUp 1632573 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		evt: 	[(20.0@23.0) mouseUp 1632573 nil]
		all: 	an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216)...etc...
		m: 	a SpToolbarButtonMorph(72545792)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216) a SpToolbarButt...etc...
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216) a SpToolbarButt...etc...

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		evt: 	[(20.0@23.0) mouseUp 1632573 nil]
		all: 	an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216)...etc...
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(20.0@23.0) mouseUp 1632573 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(20.0@23.0) mouseUp 1632573 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(72545792)
	Receiver's instance variables: 
		timeStamp: 	1632573
		source: 	a HandMorph(284116480)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(20.0@23.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(20.0@23.0) mouseUp 1632573 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(20.0@23.0) mouseUp 1632573 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(854@121) mouseUp 1632573 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(1048330240) [world]
		transformedEvent: 	[(20.0@23.0) mouseUp 1632573 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(854@121) corner: (870@137)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(854@121) corner: (870@137)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(854@121) mouseUp 1632573 nil]
		targetOffset: 	(20.0@18.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(284116480)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(1048330240) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(854@121) mouseUp 1632573 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(1048330240) [world]
		transformedEvent: 	[(20.0@23.0) mouseUp 1632573 nil]
	Receiver's instance variables: 
		bounds: 	(854@121) corner: (870@137)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(854@121) corner: (870@137)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(854@121) mouseUp 1632573 nil]
		targetOffset: 	(20.0@18.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(854@121) mouseUp 1632573 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(854@121) corner: (870@137)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(854@121) corner: (870@137)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(854@121) mouseUp 1632573 nil]
		targetOffset: 	(20.0@18.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(854@121) mouseUp 1632573 nil]
	Receiver's instance variables: 
		bounds: 	(854@121) corner: (870@137)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(854@121) corner: (870@137)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(854@121) mouseUp 1632573 nil]
		targetOffset: 	(20.0@18.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(854@121) mouseUp 1632573 nil]
		evt: 	[(854@121) mouseUp 1632573 nil]
	Receiver's instance variables: 
		bounds: 	(854@121) corner: (870@137)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(854@121) corner: (870@137)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(854@121) mouseUp 1632573 nil]
		targetOffset: 	(20.0@18.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(854@121) mouseUp 1632573 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(1048330240) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(1048330240) [world]
		queue: 	WaitfreeQueue with 30 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(284116480))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a FadingMorph(761264640))(a FadingMorp...etc...
		lastStepTime: 	1632565
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(827456000)))
		lastAlarmTime: 	1632565
		activeHand: 	a HandMorph(284116480)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1536@841)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(1048330240) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(284116480))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a FadingMorph(761264640))(a FadingMorp...etc...
		lastStepTime: 	1632565
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(827456000)))
		lastAlarmTime: 	1632565
		activeHand: 	a HandMorph(284116480)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1536@841)


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorEmptyCollection
OrderedCollection(Collection)>>emptyCheck
OrderedCollection>>removeFirst
War class>>deal:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
CollectionIsEmpty: an OrderedCollection() is empty
24 February 2023 6:24:25.492 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.536.sha.2314c3f457171dcde477ff6575b578835f1fd519 (64 Bit)]

OrderedCollection(Collection)>>errorEmptyCollection
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	39
		lastIndex: 	38


OrderedCollection(Collection)>>emptyCheck
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	39
		lastIndex: 	38


OrderedCollection>>removeFirst
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		firstObject: 	nil
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	39
		lastIndex: 	38


War class>>deal:
	Receiver: War
	Arguments and temporary variables: 
		aDeck: 	#(10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 1...etc...
		currentCard1: 	2
		currentCard2: 	2
		sortedCards: 	a SortedCollection(2 2)
		pile1: 	an OrderedCollection()
		pile2: 	an OrderedCollection(12 9 11 4 9 3 8 7 7 2 13 10 12 5 10 4 9 6 8 3 12 7 ...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#War
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#WAR


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		tests: 	#(#(1 13 1 13 1 13 1 13 12 11 12 11 12 11 12 11 10 9 10 9 10 9 10 9 8 7 ...etc...
		results: 	#(#(4 3 2 2 2 2 4 3 4 3 4 3 6 5 6 5 6 5 6 5 8 7 8 7 8 7 8 7 10 9 10 9 ...etc...
		i: 	3
		shuffling: 	#(10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 ...etc...
		should_be: 	#(1 1 13 12 9 5 11 4 9 3 8 7 7 2 13 10 12 5 10 4 9 6 8 3 1 1 13 12 7...etc...
		you_said: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| tests results |
	"
These test cases assume that the TOP of the de...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| tests results |
	"
These test cases assume that the TOP of the de...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'| tests results |

"
These test cases assume that the TOP of the deck...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 2073) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| tests results |

"
These test cases assume t...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'| tests results |

"
These test cases assume that the TOP of the deck...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 2073) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| tests results |

"
These test cases assume t...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand name...etc...
		startpc: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(72545792))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(72545792)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		event: 	[(8.0@16.0) mouseUp 1682275 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		evt: 	[(8.0@16.0) mouseUp 1682275 nil]
		all: 	an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216)...etc...
		m: 	a SpToolbarButtonMorph(72545792)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216) a SpToolbarButt...etc...
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216) a SpToolbarButt...etc...

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		evt: 	[(8.0@16.0) mouseUp 1682275 nil]
		all: 	an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216)...etc...
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(8.0@16.0) mouseUp 1682275 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(8.0@16.0) mouseUp 1682275 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(72545792)
	Receiver's instance variables: 
		timeStamp: 	1682275
		source: 	a HandMorph(284116480)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(8.0@16.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(8.0@16.0) mouseUp 1682275 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(8.0@16.0) mouseUp 1682275 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(842@114) mouseUp 1682275 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(1048330240) [world]
		transformedEvent: 	[(8.0@16.0) mouseUp 1682275 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(842@114) corner: (858@130)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(842@114) corner: (858@130)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(842@114) mouseUp 1682275 nil]
		targetOffset: 	(8.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(284116480)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(1048330240) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a Fading...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(842@114) mouseUp 1682275 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(1048330240) [world]
		transformedEvent: 	[(8.0@16.0) mouseUp 1682275 nil]
	Receiver's instance variables: 
		bounds: 	(842@114) corner: (858@130)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(842@114) corner: (858@130)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(842@114) mouseUp 1682275 nil]
		targetOffset: 	(8.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(842@114) mouseUp 1682275 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(842@114) corner: (858@130)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(842@114) corner: (858@130)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(842@114) mouseUp 1682275 nil]
		targetOffset: 	(8.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(842@114) mouseUp 1682275 nil]
	Receiver's instance variables: 
		bounds: 	(842@114) corner: (858@130)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(842@114) corner: (858@130)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(842@114) mouseUp 1682275 nil]
		targetOffset: 	(8.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(842@114) mouseUp 1682275 nil]
		evt: 	[(842@114) mouseUp 1682275 nil]
	Receiver's instance variables: 
		bounds: 	(842@114) corner: (858@130)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(842@114) corner: (858@130)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(842@114) mouseUp 1682275 nil]
		targetOffset: 	(8.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(842@114) mouseUp 1682275 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(1048330240) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(1048330240) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(284116480))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a FadingMorph(802423296))(a FadingMorp...etc...
		lastStepTime: 	1682255
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	1682255
		activeHand: 	a HandMorph(284116480)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1536@841)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a Fading...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(1048330240) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(284116480))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a FadingMorph(802423296))(a FadingMorp...etc...
		lastStepTime: 	1682255
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	1682255
		activeHand: 	a HandMorph(284116480)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1536@841)


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a Fading...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a Fading...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorEmptyCollection
OrderedCollection(Collection)>>emptyCheck
OrderedCollection>>removeFirst
War class>>deal:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
CollectionIsEmpty: an OrderedCollection() is empty
24 February 2023 6:24:25.79 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.536.sha.2314c3f457171dcde477ff6575b578835f1fd519 (64 Bit)]

OrderedCollection(Collection)>>errorEmptyCollection
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	39
		lastIndex: 	38


OrderedCollection(Collection)>>emptyCheck
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	39
		lastIndex: 	38


OrderedCollection>>removeFirst
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		firstObject: 	nil
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	39
		lastIndex: 	38


War class>>deal:
	Receiver: War
	Arguments and temporary variables: 
		aDeck: 	#(10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 1...etc...
		currentCard1: 	2
		currentCard2: 	2
		sortedCards: 	a SortedCollection(2 2)
		pile1: 	an OrderedCollection()
		pile2: 	an OrderedCollection(12 9 11 4 9 3 8 7 7 2 13 10 12 5 10 4 9 6 8 3 12 7 ...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#War
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#WAR


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		tests: 	#(#(1 13 1 13 1 13 1 13 12 11 12 11 12 11 12 11 10 9 10 9 10 9 10 9 8 7 ...etc...
		results: 	#(#(4 3 2 2 2 2 4 3 4 3 4 3 6 5 6 5 6 5 6 5 8 7 8 7 8 7 8 7 10 9 10 9 ...etc...
		i: 	3
		shuffling: 	#(10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 ...etc...
		should_be: 	#(1 1 13 12 9 5 11 4 9 3 8 7 7 2 13 10 12 5 10 4 9 6 8 3 1 1 13 12 7...etc...
		you_said: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| tests results |
	"
These test cases assume that the TOP of the de...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| tests results |
	"
These test cases assume that the TOP of the de...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'| tests results |

"
These test cases assume that the TOP of the deck...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 2073) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| tests results |

"
These test cases assume t...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'| tests results |

"
These test cases assume that the TOP of the deck...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 2073) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| tests results |

"
These test cases assume t...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButto<<error during printing>>

[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand name...etc...
		startpc: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(72545792))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(72545792)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		event: 	[(8.0@16.0) mouseUp 1682275 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		evt: 	[(8.0@16.0) mouseUp 1682275 nil]
		all: 	an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216)...etc...
		m: 	a SpToolbarButtonMorph(72545792)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216) a SpToolbarButt...etc...
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216) a SpToolbarButt...etc...

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		evt: 	[(8.0@16.0) mouseUp 1682275 nil]
		all: 	an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216)...etc...
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(8.0@16.0) mouseUp 1682275 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(8.0@16.0) mouseUp 1682275 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(72545792)
	Receiver's instance variables: 
		timeStamp: 	1682275
		source: 	a HandMorph(284116480)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(8.0@16.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(8.0@16.0) mouseUp 1682275 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(8.0@16.0) mouseUp 1682275 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(842@114) mouseUp 1682275 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(1048330240) [world]
		transformedEvent: 	[(8.0@16.0) mouseUp 1682275 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(842@114) corner: (858@130)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(842@114) corner: (858@130)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(842@114) mouseUp 1682275 nil]
		targetOffset: 	(8.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(284116480)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(1048330240) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a Fading...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(842@114) mouseUp 1682275 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(1048330240) [world]
		transformedEvent: 	[(8.0@16.0) mouseUp 1682275 nil]
	Receiver's instance variables: 
		bounds: 	(842@114) corner: (858@130)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(842@114) corner: (858@130)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(842@114) mouseUp 1682275 nil]
		targetOffset: 	(8.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(842@114) mouseUp 1682275 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(842@114) corner: (858@130)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(842@114) corner: (858@130)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(842@114) mouseUp 1682275 nil]
		targetOffset: 	(8.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(842@114) mouseUp 1682275 nil]
	Receiver's instance variables: 
		bounds: 	(842@114) corner: (858@130)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(842@114) corner: (858@130)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(842@114) mouseUp 1682275 nil]
		targetOffset: 	(8.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(842@114) mouseUp 1682275 nil]
		evt: 	[(842@114) mouseUp 1682275 nil]
	Receiver's instance variables: 
		bounds: 	(842@114) corner: (858@130)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(842@114) corner: (858@130)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(842@114) mouseUp 1682275 nil]
		targetOffset: 	(8.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(842@114) mouseUp 1682275 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(1048330240) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(1048330240) [world]
		queue: 	WaitfreeQueue with 6 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(284116480))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a FadingMorph(802423296))(a FadingMorp...etc...
		lastStepTime: 	1682255
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	1682255
		activeHand: 	a HandMorph(284116480)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1536@841)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a Fading...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(1048330240) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(284116480))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a FadingMorph(802423296))(a FadingMorp...etc...
		lastStepTime: 	1682255
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	1682255
		activeHand: 	a HandMorph(284116480)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1536@841)


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a Fading...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a Fading...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorEmptyCollection
OrderedCollection(Collection)>>emptyCheck
OrderedCollection>>removeFirst
War class>>deal:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
CollectionIsEmpty: an OrderedCollection() is empty
24 February 2023 6:25:58.434 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.536.sha.2314c3f457171dcde477ff6575b578835f1fd519 (64 Bit)]

OrderedCollection(Collection)>>errorEmptyCollection
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	39
		lastIndex: 	38


OrderedCollection(Collection)>>emptyCheck
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	39
		lastIndex: 	38


OrderedCollection>>removeFirst
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		firstObject: 	nil
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	39
		lastIndex: 	38


War class>>deal:
	Receiver: War
	Arguments and temporary variables: 
		aDeck: 	#(10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 1...etc...
		currentCard1: 	2
		currentCard2: 	2
		sortedCards: 	a SortedCollection(2 2)
		pile1: 	an OrderedCollection()
		pile2: 	an OrderedCollection(12 9 11 4 9 3 8 7 7 2 13 10 12 5 10 4 9 6 8 3 12 7 ...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#War
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#WAR


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		tests: 	#(#(1 13 1 13 1 13 1 13 12 11 12 11 12 11 12 11 10 9 10 9 10 9 10 9 8 7 ...etc...
		results: 	#(#(4 3 2 2 2 2 4 3 4 3 4 3 6 5 6 5 6 5 6 5 8 7 8 7 8 7 8 7 10 9 10 9 ...etc...
		i: 	3
		shuffling: 	#(10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 ...etc...
		should_be: 	#(1 1 13 12 9 5 11 4 9 3 8 7 7 2 13 10 12 5 10 4 9 6 8 3 1 1 13 12 7...etc...
		you_said: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| tests results |
	"
These test cases assume that the TOP of the de...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| tests results |
	"
These test cases assume that the TOP of the de...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'| tests results |

"
These test cases assume that the TOP of the deck...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 2073) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| tests results |

"
These test cases assume t...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'| tests results |

"
These test cases assume that the TOP of the deck...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 2073) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| tests results |

"
These test cases assume t...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand name...etc...
		startpc: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(72545792))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(72545792)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		event: 	[(36.0@18.0) mouseUp 1775233 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		evt: 	[(36.0@18.0) mouseUp 1775233 nil]
		all: 	an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216)...etc...
		m: 	a SpToolbarButtonMorph(72545792)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216) a SpToolbarButt...etc...
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216) a SpToolbarButt...etc...

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		evt: 	[(36.0@18.0) mouseUp 1775233 nil]
		all: 	an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216)...etc...
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(36.0@18.0) mouseUp 1775233 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(36.0@18.0) mouseUp 1775233 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(72545792)
	Receiver's instance variables: 
		timeStamp: 	1775233
		source: 	a HandMorph(284116480)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(36.0@18.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(36.0@18.0) mouseUp 1775233 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(36.0@18.0) mouseUp 1775233 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(870@116) mouseUp 1775233 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(1048330240) [world]
		transformedEvent: 	[(36.0@18.0) mouseUp 1775233 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(870@116) corner: (886@132)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(870@116) corner: (886@132)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(870@116) mouseUp 1775233 nil]
		targetOffset: 	(36.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(284116480)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(1048330240) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(870@116) mouseUp 1775233 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(1048330240) [world]
		transformedEvent: 	[(36.0@18.0) mouseUp 1775233 nil]
	Receiver's instance variables: 
		bounds: 	(870@116) corner: (886@132)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(870@116) corner: (886@132)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(870@116) mouseUp 1775233 nil]
		targetOffset: 	(36.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(870@116) mouseUp 1775233 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(870@116) corner: (886@132)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(870@116) corner: (886@132)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(870@116) mouseUp 1775233 nil]
		targetOffset: 	(36.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(870@116) mouseUp 1775233 nil]
	Receiver's instance variables: 
		bounds: 	(870@116) corner: (886@132)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(870@116) corner: (886@132)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(870@116) mouseUp 1775233 nil]
		targetOffset: 	(36.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(870@116) mouseUp 1775233 nil]
		evt: 	[(870@116) mouseUp 1775233 nil]
	Receiver's instance variables: 
		bounds: 	(870@116) corner: (886@132)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(870@116) corner: (886@132)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(870@116) mouseUp 1775233 nil]
		targetOffset: 	(36.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(870@116) mouseUp 1775233 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(1048330240) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(1048330240) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(284116480))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	1773734
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(827456000)))
		lastAlarmTime: 	1775212
		activeHand: 	a HandMorph(284116480)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1536@841)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(1048330240) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(284116480))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	1773734
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(827456000)))
		lastAlarmTime: 	1775212
		activeHand: 	a HandMorph(284116480)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1536@841)


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorEmptyCollection
OrderedCollection(Collection)>>emptyCheck
OrderedCollection>>removeFirst
War class>>deal:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
CollectionIsEmpty: an OrderedCollection() is empty
24 February 2023 6:25:58.68 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.536.sha.2314c3f457171dcde477ff6575b578835f1fd519 (64 Bit)]

OrderedCollection(Collection)>>errorEmptyCollection
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	39
		lastIndex: 	38


OrderedCollection(Collection)>>emptyCheck
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	39
		lastIndex: 	38


OrderedCollection>>removeFirst
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		firstObject: 	nil
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	39
		lastIndex: 	38


War class>>deal:
	Receiver: War
	Arguments and temporary variables: 
		aDeck: 	#(10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 1...etc...
		currentCard1: 	2
		currentCard2: 	2
		sortedCards: 	a SortedCollection(2 2)
		pile1: 	an OrderedCollection()
		pile2: 	an OrderedCollection(12 9 11 4 9 3 8 7 7 2 13 10 12 5 10 4 9 6 8 3 12 7 ...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#War
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#WAR


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		tests: 	#(#(1 13 1 13 1 13 1 13 12 11 12 11 12 11 12 11 10 9 10 9 10 9 10 9 8 7 ...etc...
		results: 	#(#(4 3 2 2 2 2 4 3 4 3 4 3 6 5 6 5 6 5 6 5 8 7 8 7 8 7 8 7 10 9 10 9 ...etc...
		i: 	3
		shuffling: 	#(10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 ...etc...
		should_be: 	#(1 1 13 12 9 5 11 4 9 3 8 7 7 2 13 10 12 5 10 4 9 6 8 3 1 1 13 12 7...etc...
		you_said: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| tests results |
	"
These test cases assume that the TOP of the de...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| tests results |
	"
These test cases assume that the TOP of the de...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'| tests results |

"
These test cases assume that the TOP of the deck...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 2073) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| tests results |

"
These test cases assume t...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'| tests results |

"
These test cases assume that the TOP of the deck...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 2073) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| tests results |

"
These test cases assume t...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
xTHERE_BE_DRAGONS_HERE
CollectionIsEmpty: an OrderedCollection() is empty
24 February 2023 6:38:12.859 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.536.sha.2314c3f457171dcde477ff6575b578835f1fd519 (64 Bit)]

OrderedCollection(Collection)>>errorEmptyCollection
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	39
		lastIndex: 	38


OrderedCollection(Collection)>>emptyCheck
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	39
		lastIndex: 	38


OrderedCollection>>removeFirst
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		firstObject: 	nil
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	39
		lastIndex: 	38


War class>>deal:
	Receiver: War
	Arguments and temporary variables: 
		aDeck: 	#(10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 1...etc...
		currentCard1: 	2
		currentCard2: 	2
		sortedCards: 	a SortedCollection(2 2)
		pile1: 	an OrderedCollection()
		pile2: 	an OrderedCollection(12 9 11 4 9 3 8 7 7 2 13 10 12 5 10 4 9 6 8 3 12 7 ...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#War
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#WAR


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		tests: 	#(#(1 13 1 13 1 13 1 13 12 11 12 11 12 11 12 11 10 9 10 9 10 9 10 9 8 7 ...etc...
		results: 	#(#(4 3 2 2 2 2 4 3 4 3 4 3 6 5 6 5 6 5 6 5 8 7 8 7 8 7 8 7 10 9 10 9 ...etc...
		i: 	3
		shuffling: 	#(10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 ...etc...
		should_be: 	#(1 1 13 12 9 5 11 4 9 3 8 7 7 2 13 10 12 5 10 4 9 6 8 3 1 1 13 12 7...etc...
		you_said: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| tests results |
	"
These test cases assume that the TOP of the de...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| tests results |
	"
These test cases assume that the TOP of the de...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'| tests results |

"
These test cases assume that the TOP of the deck...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 2073) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| tests results |

"
These test cases assume t...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'| tests results |

"
These test cases assume that the TOP of the deck...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 2073) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| tests results |

"
These test cases assume t...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand name...etc...
		startpc: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(72545792))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(72545792)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		event: 	[(23.0@18.0) mouseUp 2509656 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		evt: 	[(23.0@18.0) mouseUp 2509656 nil]
		all: 	an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216)...etc...
		m: 	a SpToolbarButtonMorph(72545792)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216) a SpToolbarButt...etc...
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216) a SpToolbarButt...etc...

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		evt: 	[(23.0@18.0) mouseUp 2509656 nil]
		all: 	an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216)...etc...
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(23.0@18.0) mouseUp 2509656 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(23.0@18.0) mouseUp 2509656 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(72545792)
	Receiver's instance variables: 
		timeStamp: 	2509656
		source: 	a HandMorph(284116480)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(23.0@18.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(23.0@18.0) mouseUp 2509656 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(23.0@18.0) mouseUp 2509656 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(857@116) mouseUp 2509656 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(1048330240) [world]
		transformedEvent: 	[(23.0@18.0) mouseUp 2509656 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(857@116) corner: (873@132)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(857@116) corner: (873@132)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(857@116) mouseUp 2509656 nil]
		targetOffset: 	(23.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(284116480)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(1048330240) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(857@116) mouseUp 2509656 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(1048330240) [world]
		transformedEvent: 	[(23.0@18.0) mouseUp 2509656 nil]
	Receiver's instance variables: 
		bounds: 	(857@116) corner: (873@132)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(857@116) corner: (873@132)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(857@116) mouseUp 2509656 nil]
		targetOffset: 	(23.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(857@116) mouseUp 2509656 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(857@116) corner: (873@132)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(857@116) corner: (873@132)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(857@116) mouseUp 2509656 nil]
		targetOffset: 	(23.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(857@116) mouseUp 2509656 nil]
	Receiver's instance variables: 
		bounds: 	(857@116) corner: (873@132)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(857@116) corner: (873@132)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(857@116) mouseUp 2509656 nil]
		targetOffset: 	(23.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(857@116) mouseUp 2509656 nil]
		evt: 	[(857@116) mouseUp 2509656 nil]
	Receiver's instance variables: 
		bounds: 	(857@116) corner: (873@132)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(857@116) corner: (873@132)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(857@116) mouseUp 2509656 nil]
		targetOffset: 	(23.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(857@116) mouseUp 2509656 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(1048330240) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(1048330240) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(284116480))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	2505054
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(827456000)))
		lastAlarmTime: 	2509635
		activeHand: 	a HandMorph(284116480)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1536@841)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(1048330240) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(284116480))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	2505054
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(827456000)))
		lastAlarmTime: 	2509635
		activeHand: 	a HandMorph(284116480)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1536@841)


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorEmptyCollection
OrderedCollection(Collection)>>emptyCheck
OrderedCollection>>removeFirst
War class>>deal:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
CollectionIsEmpty: an OrderedCollection() is empty
24 February 2023 6:38:13.115 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.536.sha.2314c3f457171dcde477ff6575b578835f1fd519 (64 Bit)]

OrderedCollection(Collection)>>errorEmptyCollection
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	39
		lastIndex: 	38


OrderedCollection(Collection)>>emptyCheck
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	39
		lastIndex: 	38


OrderedCollection>>removeFirst
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		firstObject: 	nil
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	39
		lastIndex: 	38


War class>>deal:
	Receiver: War
	Arguments and temporary variables: 
		aDeck: 	#(10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 1...etc...
		currentCard1: 	2
		currentCard2: 	2
		sortedCards: 	a SortedCollection(2 2)
		pile1: 	an OrderedCollection()
		pile2: 	an OrderedCollection(12 9 11 4 9 3 8 7 7 2 13 10 12 5 10 4 9 6 8 3 12 7 ...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#War
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#WAR


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		tests: 	#(#(1 13 1 13 1 13 1 13 12 11 12 11 12 11 12 11 10 9 10 9 10 9 10 9 8 7 ...etc...
		results: 	#(#(4 3 2 2 2 2 4 3 4 3 4 3 6 5 6 5 6 5 6 5 8 7 8 7 8 7 8 7 10 9 10 9 ...etc...
		i: 	3
		shuffling: 	#(10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 ...etc...
		should_be: 	#(1 1 13 12 9 5 11 4 9 3 8 7 7 2 13 10 12 5 10 4 9 6 8 3 1 1 13 12 7...etc...
		you_said: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| tests results |
	"
These test cases assume that the TOP of the de...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| tests results |
	"
These test cases assume that the TOP of the de...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'| tests results |

"
These test cases assume that the TOP of the deck...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 2073) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| tests results |

"
These test cases assume t...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'| tests results |

"
These test cases assume that the TOP of the deck...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 2073) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| tests results |

"
These test cases assume t...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoIt<<error during printing>>

FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand name...etc...
		startpc: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(72545792))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(72545792)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		event: 	[(23.0@18.0) mouseUp 2509656 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		evt: 	[(23.0@18.0) mouseUp 2509656 nil]
		all: 	an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216)...etc...
		m: 	a SpToolbarButtonMorph(72545792)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216) a SpToolbarButt...etc...
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216) a SpToolbarButt...etc...

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		evt: 	[(23.0@18.0) mouseUp 2509656 nil]
		all: 	an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216)...etc...
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(23.0@18.0) mouseUp 2509656 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(23.0@18.0) mouseUp 2509656 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(72545792)
	Receiver's instance variables: 
		timeStamp: 	2509656
		source: 	a HandMorph(284116480)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(23.0@18.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(23.0@18.0) mouseUp 2509656 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(23.0@18.0) mouseUp 2509656 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(857@116) mouseUp 2509656 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(1048330240) [world]
		transformedEvent: 	[(23.0@18.0) mouseUp 2509656 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(857@116) corner: (873@132)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(857@116) corner: (873@132)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(857@116) mouseUp 2509656 nil]
		targetOffset: 	(23.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(284116480)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(1048330240) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(857@116) mouseUp 2509656 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(1048330240) [world]
		transformedEvent: 	[(23.0@18.0) mouseUp 2509656 nil]
	Receiver's instance variables: 
		bounds: 	(857@116) corner: (873@132)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(857@116) corner: (873@132)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(857@116) mouseUp 2509656 nil]
		targetOffset: 	(23.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(857@116) mouseUp 2509656 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(857@116) corner: (873@132)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(857@116) corner: (873@132)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(857@116) mouseUp 2509656 nil]
		targetOffset: 	(23.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(857@116) mouseUp 2509656 nil]
	Receiver's instance variables: 
		bounds: 	(857@116) corner: (873@132)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(857@116) corner: (873@132)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(857@116) mouseUp 2509656 nil]
		targetOffset: 	(23.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(857@116) mouseUp 2509656 nil]
		evt: 	[(857@116) mouseUp 2509656 nil]
	Receiver's instance variables: 
		bounds: 	(857@116) corner: (873@132)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(857@116) corner: (873@132)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(857@116) mouseUp 2509656 nil]
		targetOffset: 	(23.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(857@116) mouseUp 2509656 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(1048330240) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(1048330240) [world]
		queue: 	WaitfreeQueue with 22 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(284116480))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	2505054
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(827456000)))
		lastAlarmTime: 	2509635
		activeHand: 	a HandMorph(284116480)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1536@841)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(1048330240) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(284116480))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	2505054
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(827456000)))
		lastAlarmTime: 	2509635
		activeHand: 	a HandMorph(284116480)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1536@841)


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorEmptyCollection
OrderedCollection(Collection)>>emptyCheck
OrderedCollection>>removeFirst
War class>>deal:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
CollectionIsEmpty: an OrderedCollection() is empty
24 February 2023 6:38:48.52 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.536.sha.2314c3f457171dcde477ff6575b578835f1fd519 (64 Bit)]

OrderedCollection(Collection)>>errorEmptyCollection
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	39
		lastIndex: 	38


OrderedCollection(Collection)>>emptyCheck
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	39
		lastIndex: 	38


OrderedCollection>>removeFirst
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		firstObject: 	nil
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	39
		lastIndex: 	38


War class>>deal:
	Receiver: War
	Arguments and temporary variables: 
		aDeck: 	#(10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 1...etc...
		currentCard1: 	2
		currentCard2: 	2
		sortedCards: 	a SortedCollection(2 2)
		pile1: 	an OrderedCollection()
		pile2: 	an OrderedCollection(12 9 11 4 9 3 8 7 7 2 13 10 12 5 10 4 9 6 8 3 12 7 ...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#War
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#WAR


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		tests: 	#(#(1 13 1 13 1 13 1 13 12 11 12 11 12 11 12 11 10 9 10 9 10 9 10 9 8 7 ...etc...
		results: 	#(#(4 3 2 2 2 2 4 3 4 3 4 3 6 5 6 5 6 5 6 5 8 7 8 7 8 7 8 7 10 9 10 9 ...etc...
		i: 	3
		shuffling: 	#(10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 ...etc...
		should_be: 	#(1 1 13 12 9 5 11 4 9 3 8 7 7 2 13 10 12 5 10 4 9 6 8 3 1 1 13 12 7...etc...
		you_said: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| tests results |
	"
These test cases assume that the TOP of the de...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| tests results |
	"
These test cases assume that the TOP of the de...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'| tests results |

"
These test cases assume that the TOP of the deck...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 2073) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| tests results |

"
These test cases assume t...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'| tests results |

"
These test cases assume that the TOP of the deck...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 2073) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| tests results |

"
These test cases assume t...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand name...etc...
		startpc: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(72545792))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(72545792)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		event: 	[(20.0@16.0) mouseUp 2545320 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		evt: 	[(20.0@16.0) mouseUp 2545320 nil]
		all: 	an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216)...etc...
		m: 	a SpToolbarButtonMorph(72545792)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216) a SpToolbarButt...etc...
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216) a SpToolbarButt...etc...

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		evt: 	[(20.0@16.0) mouseUp 2545320 nil]
		all: 	an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216)...etc...
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(20.0@16.0) mouseUp 2545320 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(20.0@16.0) mouseUp 2545320 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(72545792)
	Receiver's instance variables: 
		timeStamp: 	2545320
		source: 	a HandMorph(284116480)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(20.0@16.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(20.0@16.0) mouseUp 2545320 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(20.0@16.0) mouseUp 2545320 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(854@114) mouseUp 2545320 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(1048330240) [world]
		transformedEvent: 	[(20.0@16.0) mouseUp 2545320 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(854@114) corner: (870@130)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(854@114) corner: (870@130)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(854@114) mouseUp 2545320 nil]
		targetOffset: 	(20.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(284116480)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(1048330240) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(854@114) mouseUp 2545320 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(1048330240) [world]
		transformedEvent: 	[(20.0@16.0) mouseUp 2545320 nil]
	Receiver's instance variables: 
		bounds: 	(854@114) corner: (870@130)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(854@114) corner: (870@130)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(854@114) mouseUp 2545320 nil]
		targetOffset: 	(20.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(854@114) mouseUp 2545320 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(854@114) corner: (870@130)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(854@114) corner: (870@130)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(854@114) mouseUp 2545320 nil]
		targetOffset: 	(20.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(854@114) mouseUp 2545320 nil]
	Receiver's instance variables: 
		bounds: 	(854@114) corner: (870@130)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(854@114) corner: (870@130)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(854@114) mouseUp 2545320 nil]
		targetOffset: 	(20.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(854@114) mouseUp 2545320 nil]
		evt: 	[(854@114) mouseUp 2545320 nil]
	Receiver's instance variables: 
		bounds: 	(854@114) corner: (870@130)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(854@114) corner: (870@130)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(854@114) mouseUp 2545320 nil]
		targetOffset: 	(20.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(854@114) mouseUp 2545320 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(1048330240) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(1048330240) [world]
		queue: 	WaitfreeQueue with 1 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(284116480))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	2505054
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(827456000)))
		lastAlarmTime: 	2545299
		activeHand: 	a HandMorph(284116480)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1536@841)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(1048330240) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(284116480))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	2505054
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(827456000)))
		lastAlarmTime: 	2545299
		activeHand: 	a HandMorph(284116480)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1536@841)


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorEmptyCollection
OrderedCollection(Collection)>>emptyCheck
OrderedCollection>>removeFirst
War class>>deal:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
CollectionIsEmpty: an OrderedCollection() is empty
24 February 2023 6:38:48.788 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.536.sha.2314c3f457171dcde477ff6575b578835f1fd519 (64 Bit)]

OrderedCollection(Collection)>>errorEmptyCollection
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	39
		lastIndex: 	38


OrderedCollection(Collection)>>emptyCheck
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	39
		lastIndex: 	38


OrderedCollection>>removeFirst
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		firstObject: 	nil
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	39
		lastIndex: 	38


War class>>deal:
	Receiver: War
	Arguments and temporary variables: 
		aDeck: 	#(10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 1...etc...
		currentCard1: 	2
		currentCard2: 	2
		sortedCards: 	a SortedCollection(2 2)
		pile1: 	an OrderedCollection()
		pile2: 	an OrderedCollection(12 9 11 4 9 3 8 7 7 2 13 10 12 5 10 4 9 6 8 3 12 7 ...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#War
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#WAR


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		tests: 	#(#(1 13 1 13 1 13 1 13 12 11 12 11 12 11 12 11 10 9 10 9 10 9 10 9 8 7 ...etc...
		results: 	#(#(4 3 2 2 2 2 4 3 4 3 4 3 6 5 6 5 6 5 6 5 8 7 8 7 8 7 8 7 10 9 10 9 ...etc...
		i: 	3
		shuffling: 	#(10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 ...etc...
		should_be: 	#(1 1 13 12 9 5 11 4 9 3 8 7 7 2 13 10 12 5 10 4 9 6 8 3 1 1 13 12 7...etc...
		you_said: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| tests results |
	"
These test cases assume that the TOP of the de...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| tests results |
	"
These test cases assume that the TOP of the de...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'| tests results |

"
These test cases assume that the TOP of the deck...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 2073) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| tests results |

"
These test cases assume t...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'| tests results |

"
These test cases assume that the TOP of the deck...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 2073) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| tests results |

"
These test cases assume t...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	<<error during printing>>

StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand name...etc...
		startpc: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(72545792))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(72545792)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		event: 	[(20.0@16.0) mouseUp 2545320 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		evt: 	[(20.0@16.0) mouseUp 2545320 nil]
		all: 	an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216)...etc...
		m: 	a SpToolbarButtonMorph(72545792)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216) a SpToolbarButt...etc...
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216) a SpToolbarButt...etc...

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		evt: 	[(20.0@16.0) mouseUp 2545320 nil]
		all: 	an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216)...etc...
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(20.0@16.0) mouseUp 2545320 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(20.0@16.0) mouseUp 2545320 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(72545792)
	Receiver's instance variables: 
		timeStamp: 	2545320
		source: 	a HandMorph(284116480)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(20.0@16.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(20.0@16.0) mouseUp 2545320 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(20.0@16.0) mouseUp 2545320 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(854@114) mouseUp 2545320 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(1048330240) [world]
		transformedEvent: 	[(20.0@16.0) mouseUp 2545320 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(854@114) corner: (870@130)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(854@114) corner: (870@130)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(854@114) mouseUp 2545320 nil]
		targetOffset: 	(20.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(284116480)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(1048330240) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(854@114) mouseUp 2545320 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(1048330240) [world]
		transformedEvent: 	[(20.0@16.0) mouseUp 2545320 nil]
	Receiver's instance variables: 
		bounds: 	(854@114) corner: (870@130)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(854@114) corner: (870@130)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(854@114) mouseUp 2545320 nil]
		targetOffset: 	(20.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(854@114) mouseUp 2545320 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(854@114) corner: (870@130)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(854@114) corner: (870@130)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(854@114) mouseUp 2545320 nil]
		targetOffset: 	(20.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(854@114) mouseUp 2545320 nil]
	Receiver's instance variables: 
		bounds: 	(854@114) corner: (870@130)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(854@114) corner: (870@130)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(854@114) mouseUp 2545320 nil]
		targetOffset: 	(20.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(854@114) mouseUp 2545320 nil]
		evt: 	[(854@114) mouseUp 2545320 nil]
	Receiver's instance variables: 
		bounds: 	(854@114) corner: (870@130)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(854@114) corner: (870@130)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(854@114) mouseUp 2545320 nil]
		targetOffset: 	(20.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(854@114) mouseUp 2545320 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(1048330240) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(1048330240) [world]
		queue: 	WaitfreeQueue with 33 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(284116480))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	2505054
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(827456000)))
		lastAlarmTime: 	2545299
		activeHand: 	a HandMorph(284116480)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1536@841)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(1048330240) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(284116480))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	2505054
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(827456000)))
		lastAlarmTime: 	2545299
		activeHand: 	a HandMorph(284116480)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1536@841)


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorEmptyCollection
OrderedCollection(Collection)>>emptyCheck
OrderedCollection>>removeFirst
War class>>deal:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
CollectionIsEmpty: an OrderedCollection() is empty
24 February 2023 6:40:31.853 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.536.sha.2314c3f457171dcde477ff6575b578835f1fd519 (64 Bit)]

OrderedCollection(Collection)>>errorEmptyCollection
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	39
		lastIndex: 	38


OrderedCollection(Collection)>>emptyCheck
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	39
		lastIndex: 	38


OrderedCollection>>removeFirst
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		firstObject: 	nil
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	39
		lastIndex: 	38


War class>>deal:
	Receiver: War
	Arguments and temporary variables: 
		aDeck: 	#(10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 1...etc...
		currentCard1: 	2
		currentCard2: 	2
		sortedCards: 	a SortedCollection(2 2)
		pile1: 	an OrderedCollection()
		pile2: 	an OrderedCollection(12 9 11 4 9 3 8 7 7 2 13 10 12 5 10 4 9 6 8 3 12 7 ...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#War
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#WAR


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		tests: 	#(#(1 13 1 13 1 13 1 13 12 11 12 11 12 11 12 11 10 9 10 9 10 9 10 9 8 7 ...etc...
		results: 	#(#(4 3 2 2 2 2 4 3 4 3 4 3 6 5 6 5 6 5 6 5 8 7 8 7 8 7 8 7 10 9 10 9 ...etc...
		i: 	3
		shuffling: 	#(10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 ...etc...
		should_be: 	#(1 1 13 12 9 5 11 4 9 3 8 7 7 2 13 10 12 5 10 4 9 6 8 3 1 1 13 12 7...etc...
		you_said: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| tests results |
	"
These test cases assume that the TOP of the de...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| tests results |
	"
These test cases assume that the TOP of the de...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'| tests results |

"
These test cases assume that the TOP of the deck...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 2073) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| tests results |

"
These test cases assume t...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'| tests results |

"
These test cases assume that the TOP of the deck...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 2073) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| tests results |

"
These test cases assume t...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand name...etc...
		startpc: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(72545792))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(72545792)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		event: 	[(10.0@12.0) mouseUp 2648646 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		evt: 	[(10.0@12.0) mouseUp 2648646 nil]
		all: 	an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216)...etc...
		m: 	a SpToolbarButtonMorph(72545792)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216) a SpToolbarButt...etc...
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216) a SpToolbarButt...etc...

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		evt: 	[(10.0@12.0) mouseUp 2648646 nil]
		all: 	an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216)...etc...
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(10.0@12.0) mouseUp 2648646 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(10.0@12.0) mouseUp 2648646 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(72545792)
	Receiver's instance variables: 
		timeStamp: 	2648646
		source: 	a HandMorph(284116480)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(10.0@12.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(10.0@12.0) mouseUp 2648646 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(10.0@12.0) mouseUp 2648646 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(844@110) mouseUp 2648646 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(1048330240) [world]
		transformedEvent: 	[(10.0@12.0) mouseUp 2648646 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(844@110) corner: (860@126)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(844@110) corner: (860@126)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(844@110) mouseUp 2648646 nil]
		targetOffset: 	(10.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(284116480)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(1048330240) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(844@110) mouseUp 2648646 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(1048330240) [world]
		transformedEvent: 	[(10.0@12.0) mouseUp 2648646 nil]
	Receiver's instance variables: 
		bounds: 	(844@110) corner: (860@126)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(844@110) corner: (860@126)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(844@110) mouseUp 2648646 nil]
		targetOffset: 	(10.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(844@110) mouseUp 2648646 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(844@110) corner: (860@126)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(844@110) corner: (860@126)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(844@110) mouseUp 2648646 nil]
		targetOffset: 	(10.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(844@110) mouseUp 2648646 nil]
	Receiver's instance variables: 
		bounds: 	(844@110) corner: (860@126)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(844@110) corner: (860@126)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(844@110) mouseUp 2648646 nil]
		targetOffset: 	(10.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(844@110) mouseUp 2648646 nil]
		evt: 	[(844@110) mouseUp 2648646 nil]
	Receiver's instance variables: 
		bounds: 	(844@110) corner: (860@126)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(844@110) corner: (860@126)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(844@110) mouseUp 2648646 nil]
		targetOffset: 	(10.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(844@110) mouseUp 2648646 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(1048330240) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(1048330240) [world]
		queue: 	WaitfreeQueue with 18 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(284116480))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	2647696
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(827456000)))
		lastAlarmTime: 	2648625
		activeHand: 	a HandMorph(284116480)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1536@841)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(1048330240) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(284116480))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	2647696
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(827456000)))
		lastAlarmTime: 	2648625
		activeHand: 	a HandMorph(284116480)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1536@841)


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorEmptyCollection
OrderedCollection(Collection)>>emptyCheck
OrderedCollection>>removeFirst
War class>>deal:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
CollectionIsEmpty: an OrderedCollection() is empty
24 February 2023 6:40:32.131 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.536.sha.2314c3f457171dcde477ff6575b578835f1fd519 (64 Bit)]

OrderedCollection(Collection)>>errorEmptyCollection
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	39
		lastIndex: 	38


OrderedCollection(Collection)>>emptyCheck
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	39
		lastIndex: 	38


OrderedCollection>>removeFirst
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		firstObject: 	nil
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	39
		lastIndex: 	38


War class>>deal:
	Receiver: War
	Arguments and temporary variables: 
		aDeck: 	#(10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 1...etc...
		currentCard1: 	2
		currentCard2: 	2
		sortedCards: 	a SortedCollection(2 2)
		pile1: 	an OrderedCollection()
		pile2: 	an OrderedCollection(12 9 11 4 9 3 8 7 7 2 13 10 12 5 10 4 9 6 8 3 12 7 ...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#War
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#WAR


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		tests: 	#(#(1 13 1 13 1 13 1 13 12 11 12 11 12 11 12 11 10 9 10 9 10 9 10 9 8 7 ...etc...
		results: 	#(#(4 3 2 2 2 2 4 3 4 3 4 3 6 5 6 5 6 5 6 5 8 7 8 7 8 7 8 7 10 9 10 9 ...etc...
		i: 	3
		shuffling: 	#(10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 ...etc...
		should_be: 	#(1 1 13 12 9 5 11 4 9 3 8 7 7 2 13 10 12 5 10 4 9 6 8 3 1 1 13 12 7...etc...
		you_said: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| tests results |
	"
These test cases assume that the TOP of the de...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| tests results |
	"
These test cases assume that the TOP of the de...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'| tests results |

"
These test cases assume that the TOP of the deck...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 2073) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| tests results |

"
These test cases assume t...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'| tests results |

"
These test cases assume that the TOP of the deck...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 2073) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| tests results |

"
These test cases assume t...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		tool<<error during printing>>

StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand name...etc...
		startpc: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(72545792))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(72545792)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		event: 	[(10.0@12.0) mouseUp 2648646 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		evt: 	[(10.0@12.0) mouseUp 2648646 nil]
		all: 	an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216)...etc...
		m: 	a SpToolbarButtonMorph(72545792)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216) a SpToolbarButt...etc...
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216) a SpToolbarButt...etc...

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		evt: 	[(10.0@12.0) mouseUp 2648646 nil]
		all: 	an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216)...etc...
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(10.0@12.0) mouseUp 2648646 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(10.0@12.0) mouseUp 2648646 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(72545792)
	Receiver's instance variables: 
		timeStamp: 	2648646
		source: 	a HandMorph(284116480)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(10.0@12.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(10.0@12.0) mouseUp 2648646 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(10.0@12.0) mouseUp 2648646 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(844@110) mouseUp 2648646 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(1048330240) [world]
		transformedEvent: 	[(10.0@12.0) mouseUp 2648646 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(844@110) corner: (860@126)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(844@110) corner: (860@126)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(844@110) mouseUp 2648646 nil]
		targetOffset: 	(10.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(284116480)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(1048330240) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(844@110) mouseUp 2648646 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(1048330240) [world]
		transformedEvent: 	[(10.0@12.0) mouseUp 2648646 nil]
	Receiver's instance variables: 
		bounds: 	(844@110) corner: (860@126)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(844@110) corner: (860@126)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(844@110) mouseUp 2648646 nil]
		targetOffset: 	(10.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(844@110) mouseUp 2648646 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(844@110) corner: (860@126)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(844@110) corner: (860@126)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(844@110) mouseUp 2648646 nil]
		targetOffset: 	(10.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(844@110) mouseUp 2648646 nil]
	Receiver's instance variables: 
		bounds: 	(844@110) corner: (860@126)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(844@110) corner: (860@126)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(844@110) mouseUp 2648646 nil]
		targetOffset: 	(10.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(844@110) mouseUp 2648646 nil]
		evt: 	[(844@110) mouseUp 2648646 nil]
	Receiver's instance variables: 
		bounds: 	(844@110) corner: (860@126)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(844@110) corner: (860@126)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(844@110) mouseUp 2648646 nil]
		targetOffset: 	(10.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(844@110) mouseUp 2648646 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(1048330240) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(1048330240) [world]
		queue: 	WaitfreeQueue with 55 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(284116480))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	2647696
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(827456000)))
		lastAlarmTime: 	2648625
		activeHand: 	a HandMorph(284116480)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1536@841)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(1048330240) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(284116480))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	2647696
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(827456000)))
		lastAlarmTime: 	2648625
		activeHand: 	a HandMorph(284116480)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1536@841)


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorEmptyCollection
OrderedCollection(Collection)>>emptyCheck
OrderedCollection>>removeFirst
War class>>deal:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
CollectionIsEmpty: an OrderedCollection() is empty
24 February 2023 6:42:25.347 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.536.sha.2314c3f457171dcde477ff6575b578835f1fd519 (64 Bit)]

OrderedCollection(Collection)>>errorEmptyCollection
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	39
		lastIndex: 	38


OrderedCollection(Collection)>>emptyCheck
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	39
		lastIndex: 	38


OrderedCollection>>removeFirst
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		firstObject: 	nil
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	39
		lastIndex: 	38


War class>>deal:
	Receiver: War
	Arguments and temporary variables: 
		aDeck: 	#(10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 1...etc...
		currentCard1: 	2
		currentCard2: 	2
		sortedCards: 	a SortedCollection(2 2)
		pile1: 	an OrderedCollection()
		pile2: 	an OrderedCollection(12 9 5 13 14 14 11 4 9 3 8 7 7 2 13 10 12 5 10 4 9 ...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#War
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#WAR


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		tests: 	#(#(1 13 1 13 1 13 1 13 12 11 12 11 12 11 12 11 10 9 10 9 10 9 10 9 8 7 ...etc...
		results: 	#(#(4 3 2 2 2 2 4 3 4 3 4 3 6 5 6 5 6 5 6 5 8 7 8 7 8 7 8 7 10 9 10 9 ...etc...
		i: 	3
		shuffling: 	#(10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 ...etc...
		should_be: 	#(1 1 13 12 9 5 11 4 9 3 8 7 7 2 13 10 12 5 10 4 9 6 8 3 1 1 13 12 7...etc...
		you_said: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| tests results |
	"
These test cases assume that the TOP of the de...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| tests results |
	"
These test cases assume that the TOP of the de...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'| tests results |

"
These test cases assume that the TOP of the deck...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 2073) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| tests results |

"
These test cases assume t...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'| tests results |

"
These test cases assume that the TOP of the deck...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 2073) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| tests results |

"
These test cases assume t...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand name...etc...
		startpc: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(72545792))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(72545792)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		event: 	[(29.0@14.0) mouseUp 2762134 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		evt: 	[(29.0@14.0) mouseUp 2762134 nil]
		all: 	an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216)...etc...
		m: 	a SpToolbarButtonMorph(72545792)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216) a SpToolbarButt...etc...
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216) a SpToolbarButt...etc...

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		evt: 	[(29.0@14.0) mouseUp 2762134 nil]
		all: 	an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216)...etc...
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(29.0@14.0) mouseUp 2762134 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(29.0@14.0) mouseUp 2762134 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(72545792)
	Receiver's instance variables: 
		timeStamp: 	2762134
		source: 	a HandMorph(284116480)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(29.0@14.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(29.0@14.0) mouseUp 2762134 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(29.0@14.0) mouseUp 2762134 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(863@112) mouseUp 2762134 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(1048330240) [world]
		transformedEvent: 	[(29.0@14.0) mouseUp 2762134 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(863@112) corner: (879@128)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(863@112) corner: (879@128)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(863@112) mouseUp 2762134 nil]
		targetOffset: 	(29.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(284116480)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(1048330240) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(863@112) mouseUp 2762134 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(1048330240) [world]
		transformedEvent: 	[(29.0@14.0) mouseUp 2762134 nil]
	Receiver's instance variables: 
		bounds: 	(863@112) corner: (879@128)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(863@112) corner: (879@128)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(863@112) mouseUp 2762134 nil]
		targetOffset: 	(29.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(863@112) mouseUp 2762134 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(863@112) corner: (879@128)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(863@112) corner: (879@128)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(863@112) mouseUp 2762134 nil]
		targetOffset: 	(29.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(863@112) mouseUp 2762134 nil]
	Receiver's instance variables: 
		bounds: 	(863@112) corner: (879@128)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(863@112) corner: (879@128)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(863@112) mouseUp 2762134 nil]
		targetOffset: 	(29.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(863@112) mouseUp 2762134 nil]
		evt: 	[(863@112) mouseUp 2762134 nil]
	Receiver's instance variables: 
		bounds: 	(863@112) corner: (879@128)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(863@112) corner: (879@128)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(863@112) mouseUp 2762134 nil]
		targetOffset: 	(29.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(863@112) mouseUp 2762134 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(1048330240) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(1048330240) [world]
		queue: 	WaitfreeQueue with 12 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(284116480))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	2760927
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(827456000)))
		lastAlarmTime: 	2762124
		activeHand: 	a HandMorph(284116480)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1536@841)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(1048330240) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(284116480))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	2760927
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(827456000)))
		lastAlarmTime: 	2762124
		activeHand: 	a HandMorph(284116480)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1536@841)


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorEmptyCollection
OrderedCollection(Collection)>>emptyCheck
OrderedCollection>>removeFirst
War class>>deal:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
CollectionIsEmpty: an OrderedCollection() is empty
24 February 2023 6:42:25.608 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.536.sha.2314c3f457171dcde477ff6575b578835f1fd519 (64 Bit)]

OrderedCollection(Collection)>>errorEmptyCollection
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	39
		lastIndex: 	38


OrderedCollection(Collection)>>emptyCheck
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	39
		lastIndex: 	38


OrderedCollection>>removeFirst
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		firstObject: 	nil
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	39
		lastIndex: 	38


War class>>deal:
	Receiver: War
	Arguments and temporary variables: 
		aDeck: 	#(10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 1...etc...
		currentCard1: 	2
		currentCard2: 	2
		sortedCards: 	a SortedCollection(2 2)
		pile1: 	an OrderedCollection()
		pile2: 	an OrderedCollection(12 9 5 13 14 14 11 4 9 3 8 7 7 2 13 10 12 5 10 4 9 ...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#War
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#WAR


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		tests: 	#(#(1 13 1 13 1 13 1 13 12 11 12 11 12 11 12 11 10 9 10 9 10 9 10 9 8 7 ...etc...
		results: 	#(#(4 3 2 2 2 2 4 3 4 3 4 3 6 5 6 5 6 5 6 5 8 7 8 7 8 7 8 7 10 9 10 9 ...etc...
		i: 	3
		shuffling: 	#(10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 ...etc...
		should_be: 	#(1 1 13 12 9 5 11 4 9 3 8 7 7 2 13 10 12 5 10 4 9 6 8 3 1 1 13 12 7...etc...
		you_said: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| tests results |
	"
These test cases assume that the TOP of the de...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| tests results |
	"
These test cases assume that the TOP of the de...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'| tests results |

"
These test cases assume that the TOP of the deck...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 2073) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| tests results |

"
These test cases assume t...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'| tests results |

"
These test cases assume that the TOP of the deck...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 2073) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| tests results |

"
These test cases assume t...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		dis<<error during printing>>

[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand name...etc...
		startpc: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(72545792))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(72545792)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		event: 	[(29.0@14.0) mouseUp 2762134 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		evt: 	[(29.0@14.0) mouseUp 2762134 nil]
		all: 	an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216)...etc...
		m: 	a SpToolbarButtonMorph(72545792)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216) a SpToolbarButt...etc...
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216) a SpToolbarButt...etc...

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		evt: 	[(29.0@14.0) mouseUp 2762134 nil]
		all: 	an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216)...etc...
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(29.0@14.0) mouseUp 2762134 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(29.0@14.0) mouseUp 2762134 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(72545792)
	Receiver's instance variables: 
		timeStamp: 	2762134
		source: 	a HandMorph(284116480)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(29.0@14.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(29.0@14.0) mouseUp 2762134 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(29.0@14.0) mouseUp 2762134 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(863@112) mouseUp 2762134 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(1048330240) [world]
		transformedEvent: 	[(29.0@14.0) mouseUp 2762134 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(863@112) corner: (879@128)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(863@112) corner: (879@128)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(863@112) mouseUp 2762134 nil]
		targetOffset: 	(29.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(284116480)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(1048330240) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(863@112) mouseUp 2762134 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(1048330240) [world]
		transformedEvent: 	[(29.0@14.0) mouseUp 2762134 nil]
	Receiver's instance variables: 
		bounds: 	(863@112) corner: (879@128)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(863@112) corner: (879@128)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(863@112) mouseUp 2762134 nil]
		targetOffset: 	(29.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(863@112) mouseUp 2762134 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(863@112) corner: (879@128)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(863@112) corner: (879@128)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(863@112) mouseUp 2762134 nil]
		targetOffset: 	(29.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(863@112) mouseUp 2762134 nil]
	Receiver's instance variables: 
		bounds: 	(863@112) corner: (879@128)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(863@112) corner: (879@128)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(863@112) mouseUp 2762134 nil]
		targetOffset: 	(29.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(863@112) mouseUp 2762134 nil]
		evt: 	[(863@112) mouseUp 2762134 nil]
	Receiver's instance variables: 
		bounds: 	(863@112) corner: (879@128)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(863@112) corner: (879@128)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(863@112) mouseUp 2762134 nil]
		targetOffset: 	(29.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(863@112) mouseUp 2762134 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(1048330240) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(1048330240) [world]
		queue: 	WaitfreeQueue with 44 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(284116480))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	2760927
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(827456000)))
		lastAlarmTime: 	2762124
		activeHand: 	a HandMorph(284116480)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1536@841)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(1048330240) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(284116480))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	2760927
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(827456000)))
		lastAlarmTime: 	2762124
		activeHand: 	a HandMorph(284116480)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1536@841)


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorEmptyCollection
OrderedCollection(Collection)>>emptyCheck
OrderedCollection>>removeFirst
War class>>deal:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
CollectionIsEmpty: an OrderedCollection() is empty
24 February 2023 6:45:24.431 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.536.sha.2314c3f457171dcde477ff6575b578835f1fd519 (64 Bit)]

OrderedCollection(Collection)>>errorEmptyCollection
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	39
		lastIndex: 	38


OrderedCollection(Collection)>>emptyCheck
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	39
		lastIndex: 	38


OrderedCollection>>removeFirst
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		firstObject: 	nil
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	39
		lastIndex: 	38


War class>>deal:
	Receiver: War
	Arguments and temporary variables: 
		aDeck: 	#(10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 1...etc...
		currentCard1: 	2
		currentCard2: 	2
		sortedCards: 	a SortedCollection(2 2)
		pile1: 	an OrderedCollection()
		pile2: 	an OrderedCollection(12 9 5 13 14 14 11 4 9 3 8 7 7 2 13 10 12 5 10 4 9 ...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#War
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#WAR


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		tests: 	#(#(1 13 1 13 1 13 1 13 12 11 12 11 12 11 12 11 10 9 10 9 10 9 10 9 8 7 ...etc...
		results: 	#(#(4 3 2 2 2 2 4 3 4 3 4 3 6 5 6 5 6 5 6 5 8 7 8 7 8 7 8 7 10 9 10 9 ...etc...
		i: 	3
		shuffling: 	#(10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 ...etc...
		should_be: 	#(1 1 13 12 9 5 11 4 9 3 8 7 7 2 13 10 12 5 10 4 9 6 8 3 1 1 13 12 7...etc...
		you_said: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| tests results |
	"
These test cases assume that the TOP of the de...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| tests results |
	"
These test cases assume that the TOP of the de...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'| tests results |

"
These test cases assume that the TOP of the deck...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 2081) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| tests results |

"
These test cases assume t...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'| tests results |

"
These test cases assume that the TOP of the deck...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 2081) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| tests results |

"
These test cases assume t...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand name...etc...
		startpc: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(72545792))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(72545792)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		event: 	[(32.0@30.0) mouseUp 2941223 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		evt: 	[(32.0@30.0) mouseUp 2941223 nil]
		all: 	an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216)...etc...
		m: 	a SpToolbarButtonMorph(72545792)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216) a SpToolbarButt...etc...
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216) a SpToolbarButt...etc...

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		evt: 	[(32.0@30.0) mouseUp 2941223 nil]
		all: 	an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216)...etc...
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(32.0@30.0) mouseUp 2941223 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(32.0@30.0) mouseUp 2941223 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(72545792)
	Receiver's instance variables: 
		timeStamp: 	2941223
		source: 	a HandMorph(284116480)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(32.0@30.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(32.0@30.0) mouseUp 2941223 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(32.0@30.0) mouseUp 2941223 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(866@128) mouseUp 2941223 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(1048330240) [world]
		transformedEvent: 	[(32.0@30.0) mouseUp 2941223 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(866@128.0) corner: (882@144.0)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(866@128.0) corner: (882@144.0)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(866@128) mouseUp 2941223 nil]
		targetOffset: 	(32.0@25.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(284116480)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(1048330240) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(866@128) mouseUp 2941223 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(1048330240) [world]
		transformedEvent: 	[(32.0@30.0) mouseUp 2941223 nil]
	Receiver's instance variables: 
		bounds: 	(866@128.0) corner: (882@144.0)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(866@128.0) corner: (882@144.0)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(866@128) mouseUp 2941223 nil]
		targetOffset: 	(32.0@25.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(866@128) mouseUp 2941223 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(866@128.0) corner: (882@144.0)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(866@128.0) corner: (882@144.0)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(866@128) mouseUp 2941223 nil]
		targetOffset: 	(32.0@25.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(866@128) mouseUp 2941223 nil]
	Receiver's instance variables: 
		bounds: 	(866@128.0) corner: (882@144.0)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(866@128.0) corner: (882@144.0)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(866@128) mouseUp 2941223 nil]
		targetOffset: 	(32.0@25.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(866@128) mouseUp 2941223 nil]
		evt: 	[(866@128) mouseUp 2941223 nil]
	Receiver's instance variables: 
		bounds: 	(866@128.0) corner: (882@144.0)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(866@128.0) corner: (882@144.0)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(866@128) mouseUp 2941223 nil]
		targetOffset: 	(32.0@25.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(866@128) mouseUp 2941223 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(1048330240) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(1048330240) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(284116480))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	2760927
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(827456000)))
		lastAlarmTime: 	2941203
		activeHand: 	a HandMorph(284116480)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1536@841)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(1048330240) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(284116480))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	2760927
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(827456000)))
		lastAlarmTime: 	2941203
		activeHand: 	a HandMorph(284116480)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1536@841)


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorEmptyCollection
OrderedCollection(Collection)>>emptyCheck
OrderedCollection>>removeFirst
War class>>deal:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
CollectionIsEmpty: an OrderedCollection() is empty
24 February 2023 6:45:24.671 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.536.sha.2314c3f457171dcde477ff6575b578835f1fd519 (64 Bit)]

OrderedCollection(Collection)>>errorEmptyCollection
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	39
		lastIndex: 	38


OrderedCollection(Collection)>>emptyCheck
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	39
		lastIndex: 	38


OrderedCollection>>removeFirst
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		firstObject: 	nil
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	39
		lastIndex: 	38


War class>>deal:
	Receiver: War
	Arguments and temporary variables: 
		aDeck: 	#(10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 1...etc...
		currentCard1: 	2
		currentCard2: 	2
		sortedCards: 	a SortedCollection(2 2)
		pile1: 	an OrderedCollection()
		pile2: 	an OrderedCollection(12 9 5 13 14 14 11 4 9 3 8 7 7 2 13 10 12 5 10 4 9 ...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#War
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#WAR


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		tests: 	#(#(1 13 1 13 1 13 1 13 12 11 12 11 12 11 12 11 10 9 10 9 10 9 10 9 8 7 ...etc...
		results: 	#(#(4 3 2 2 2 2 4 3 4 3 4 3 6 5 6 5 6 5 6 5 8 7 8 7 8 7 8 7 10 9 10 9 ...etc...
		i: 	3
		shuffling: 	#(10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 ...etc...
		should_be: 	#(1 1 13 12 9 5 11 4 9 3 8 7 7 2 13 10 12 5 10 4 9 6 8 3 1 1 13 12 7...etc...
		you_said: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| tests results |
	"
These test cases assume that the TOP of the de...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| tests results |
	"
These test cases assume that the TOP of the de...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'| tests results |

"
These test cases assume that the TOP of the deck...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 2081) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| tests results |

"
These test cases assume t...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'| tests results |

"
These test cases assume that the TOP of the deck...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 2081) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| tests results |

"
These test cases assume t...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoI<<error during printing>>

[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand name...etc...
		startpc: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(72545792))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(72545792)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		event: 	[(32.0@30.0) mouseUp 2941223 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		evt: 	[(32.0@30.0) mouseUp 2941223 nil]
		all: 	an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216)...etc...
		m: 	a SpToolbarButtonMorph(72545792)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216) a SpToolbarButt...etc...
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216) a SpToolbarButt...etc...

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		evt: 	[(32.0@30.0) mouseUp 2941223 nil]
		all: 	an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216)...etc...
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(32.0@30.0) mouseUp 2941223 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(32.0@30.0) mouseUp 2941223 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(72545792)
	Receiver's instance variables: 
		timeStamp: 	2941223
		source: 	a HandMorph(284116480)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(32.0@30.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(32.0@30.0) mouseUp 2941223 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(32.0@30.0) mouseUp 2941223 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(866@128) mouseUp 2941223 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(1048330240) [world]
		transformedEvent: 	[(32.0@30.0) mouseUp 2941223 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(866@128.0) corner: (882@144.0)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(866@128.0) corner: (882@144.0)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(866@128) mouseUp 2941223 nil]
		targetOffset: 	(32.0@25.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(284116480)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(1048330240) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(866@128) mouseUp 2941223 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(1048330240) [world]
		transformedEvent: 	[(32.0@30.0) mouseUp 2941223 nil]
	Receiver's instance variables: 
		bounds: 	(866@128.0) corner: (882@144.0)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(866@128.0) corner: (882@144.0)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(866@128) mouseUp 2941223 nil]
		targetOffset: 	(32.0@25.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(866@128) mouseUp 2941223 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(866@128.0) corner: (882@144.0)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(866@128.0) corner: (882@144.0)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(866@128) mouseUp 2941223 nil]
		targetOffset: 	(32.0@25.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(866@128) mouseUp 2941223 nil]
	Receiver's instance variables: 
		bounds: 	(866@128.0) corner: (882@144.0)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(866@128.0) corner: (882@144.0)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(866@128) mouseUp 2941223 nil]
		targetOffset: 	(32.0@25.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(866@128) mouseUp 2941223 nil]
		evt: 	[(866@128) mouseUp 2941223 nil]
	Receiver's instance variables: 
		bounds: 	(866@128.0) corner: (882@144.0)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(866@128.0) corner: (882@144.0)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(866@128) mouseUp 2941223 nil]
		targetOffset: 	(32.0@25.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(866@128) mouseUp 2941223 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(1048330240) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(1048330240) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(284116480))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	2760927
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(827456000)))
		lastAlarmTime: 	2941203
		activeHand: 	a HandMorph(284116480)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1536@841)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(1048330240) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(284116480))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	2760927
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(827456000)))
		lastAlarmTime: 	2941203
		activeHand: 	a HandMorph(284116480)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1536@841)


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorEmptyCollection
OrderedCollection(Collection)>>emptyCheck
OrderedCollection>>removeFirst
War class>>deal:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
CollectionIsEmpty: an OrderedCollection() is empty
24 February 2023 6:51:31.859 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.536.sha.2314c3f457171dcde477ff6575b578835f1fd519 (64 Bit)]

OrderedCollection(Collection)>>errorEmptyCollection
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	39
		lastIndex: 	38


OrderedCollection(Collection)>>emptyCheck
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	39
		lastIndex: 	38


OrderedCollection>>removeFirst
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		firstObject: 	nil
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	39
		lastIndex: 	38


War class>>deal:
	Receiver: War
	Arguments and temporary variables: 
		aDeck: 	#(10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 1...etc...
		currentCard1: 	2
		currentCard2: 	2
		sortedCards: 	a SortedCollection(2 2)
		pile1: 	an OrderedCollection()
		pile2: 	an OrderedCollection(14 14 13 12 9 5 11 4 9 3 8 7 7 2 13 10 12 5 10 4 9 ...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#War
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#WAR


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		tests: 	#(#(1 13 1 13 1 13 1 13 12 11 12 11 12 11 12 11 10 9 10 9 10 9 10 9 8 7 ...etc...
		results: 	#(#(4 3 2 2 2 2 4 3 4 3 4 3 6 5 6 5 6 5 6 5 8 7 8 7 8 7 8 7 10 9 10 9 ...etc...
		i: 	3
		shuffling: 	#(10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 ...etc...
		should_be: 	#(1 1 13 12 9 5 11 4 9 3 8 7 7 2 13 10 12 5 10 4 9 6 8 3 1 1 13 12 7...etc...
		you_said: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| tests results |
	"
These test cases assume that the TOP of the de...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| tests results |
	"
These test cases assume that the TOP of the de...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'| tests results |

"
These test cases assume that the TOP of the deck...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 2081) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| tests results |

"
These test cases assume t...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'| tests results |

"
These test cases assume that the TOP of the deck...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 2081) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| tests results |

"
These test cases assume t...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand name...etc...
		startpc: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(72545792))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(72545792)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		event: 	[(7.0@28.0) mouseUp 3308651 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		evt: 	[(7.0@28.0) mouseUp 3308651 nil]
		all: 	an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216)...etc...
		m: 	a SpToolbarButtonMorph(72545792)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216) a SpToolbarButt...etc...
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216) a SpToolbarButt...etc...

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		evt: 	[(7.0@28.0) mouseUp 3308651 nil]
		all: 	an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216)...etc...
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(7.0@28.0) mouseUp 3308651 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(7.0@28.0) mouseUp 3308651 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(72545792)
	Receiver's instance variables: 
		timeStamp: 	3308651
		source: 	a HandMorph(284116480)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(7.0@28.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(7.0@28.0) mouseUp 3308651 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(7.0@28.0) mouseUp 3308651 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(841@126) mouseUp 3308651 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(1048330240) [world]
		transformedEvent: 	[(7.0@28.0) mouseUp 3308651 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(841@126.0) corner: (857@142.0)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(841@126.0) corner: (857@142.0)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(841@126) mouseUp 3308651 nil]
		targetOffset: 	(7.0@23.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(284116480)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(1048330240) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(841@126) mouseUp 3308651 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(1048330240) [world]
		transformedEvent: 	[(7.0@28.0) mouseUp 3308651 nil]
	Receiver's instance variables: 
		bounds: 	(841@126.0) corner: (857@142.0)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(841@126.0) corner: (857@142.0)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(841@126) mouseUp 3308651 nil]
		targetOffset: 	(7.0@23.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(841@126) mouseUp 3308651 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(841@126.0) corner: (857@142.0)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(841@126.0) corner: (857@142.0)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(841@126) mouseUp 3308651 nil]
		targetOffset: 	(7.0@23.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(841@126) mouseUp 3308651 nil]
	Receiver's instance variables: 
		bounds: 	(841@126.0) corner: (857@142.0)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(841@126.0) corner: (857@142.0)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(841@126) mouseUp 3308651 nil]
		targetOffset: 	(7.0@23.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(841@126) mouseUp 3308651 nil]
		evt: 	[(841@126) mouseUp 3308651 nil]
	Receiver's instance variables: 
		bounds: 	(841@126.0) corner: (857@142.0)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(841@126.0) corner: (857@142.0)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(841@126) mouseUp 3308651 nil]
		targetOffset: 	(7.0@23.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(841@126) mouseUp 3308651 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(1048330240) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(1048330240) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(284116480))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	3297863
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(827456000)))
		lastAlarmTime: 	3308636
		activeHand: 	a HandMorph(284116480)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1536@841)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(1048330240) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(284116480))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	3297863
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(827456000)))
		lastAlarmTime: 	3308636
		activeHand: 	a HandMorph(284116480)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1536@841)


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
OrderedCollection(Collection)>>errorEmptyCollection
OrderedCollection(Collection)>>emptyCheck
OrderedCollection>>removeFirst
War class>>deal:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
CollectionIsEmpty: an OrderedCollection() is empty
24 February 2023 6:51:32.117 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.536.sha.2314c3f457171dcde477ff6575b578835f1fd519 (64 Bit)]

OrderedCollection(Collection)>>errorEmptyCollection
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	39
		lastIndex: 	38


OrderedCollection(Collection)>>emptyCheck
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	39
		lastIndex: 	38


OrderedCollection>>removeFirst
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		firstObject: 	nil
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	39
		lastIndex: 	38


War class>>deal:
	Receiver: War
	Arguments and temporary variables: 
		aDeck: 	#(10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 1...etc...
		currentCard1: 	2
		currentCard2: 	2
		sortedCards: 	a SortedCollection(2 2)
		pile1: 	an OrderedCollection()
		pile2: 	an OrderedCollection(14 14 13 12 9 5 11 4 9 3 8 7 7 2 13 10 12 5 10 4 9 ...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#War
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#WAR


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		tests: 	#(#(1 13 1 13 1 13 1 13 12 11 12 11 12 11 12 11 10 9 10 9 10 9 10 9 8 7 ...etc...
		results: 	#(#(4 3 2 2 2 2 4 3 4 3 4 3 6 5 6 5 6 5 6 5 8 7 8 7 8 7 8 7 10 9 10 9 ...etc...
		i: 	3
		shuffling: 	#(10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 ...etc...
		should_be: 	#(1 1 13 12 9 5 11 4 9 3 8 7 7 2 13 10 12 5 10 4 9 6 8 3 1 1 13 12 7...etc...
		you_said: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| tests results |
	"
These test cases assume that the TOP of the de...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| tests results |
	"
These test cases assume that the TOP of the de...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'| tests results |

"
These test cases assume that the TOP of the deck...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 2081) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| tests results |

"
These test cases assume t...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'| tests results |

"
These test cases assume that the TOP of the deck...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 2081) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| tests results |

"
These test cases assume t...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	ArgumTHERE_BE_DRAGONS_HERE
Instance of GPoint did not understand #,
24 February 2023 9:02:05.947 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.536.sha.2314c3f457171dcde477ff6575b578835f1fd519 (64 Bit)]

GPoint(Object)>>doesNotUnderstand: #,
	Receiver: a GPoint(5,10)
	Arguments and temporary variables: 
		aMessage: 	, 11
		exception: 	Instance of GPoint did not understand #,
		resumeValue: 	nil
	Receiver's instance variables: 
		coordinates: 	(5,10)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	array := 5 , 10 , 11 , 9 , 3 , 8 , 3 , 6 , 2 , 1 , 8 , 6 , 12 , 7
	...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	array := 5 , 10 , 11 , 9 , 3 , 8 , 3 , 6 , 2 , 1 , 8 , 6 , 12 , 7
	...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'array := (5, 10, 11, 9, 3, 8, 3, 6, 2, 1, 8, 6, 12, 7, 13, 9, 1, 7, 1...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#array->#(5 #, 10 #, 11 #, 9 #, 3 #, 8 #, 3 #, 6 #, 2...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (2336 to: 2544) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| tests results array|

"
These test cases ass...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#array->#(5 #, 10 #, 11 #, 9 #, 3 #, 8 #, 3 #, 6 #, 2...etc...
		aString: 	'array := (5, 10, 11, 9, 3, 8, 3, 6, 2, 1, 8, 6, 12, 7, 13, 9, 1, 7, 1...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (2336 to: 2544) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| tests results array|

"
These test cases ass...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'array := (5, 10, 11, 9, 3, 8, 3, 6, 2, 1, 8, 6, 12, 7, 13, 9, 1, 7, 1...etc...
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'array := (5, 10, 11, 9, 3, 8, 3, 6, 2, 1, 8, 6, 12, 7, 13, 9, 1, 7,...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(651665920)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(651665920)
		secondArg: 	a RubEditingArea(651665920)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(651665920)
		secondArg: 	a RubEditingArea(651665920)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(651665920)
		category: 	a KMCategory
		morph: 	a RubEditingArea(651665920)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	14
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(651665920)
		category: 	a KMCategory
		morph: 	a RubEditingArea(651665920)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#MorphFocusCtrlNavigation) a KMCategoryBindi...etc...
		morph: 	a RubEditingArea(651665920)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#MorphFocusCtrlNavigatio...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
		...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#MorphFocusCtrlNav...etc...
		firstIndex: 	1
		lastIndex: 	4



--- The full stack ---
GPoint(Object)>>doesNotUnderstand: #,
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of GPoint did not understand #,
24 February 2023 9:02:06.182 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.536.sha.2314c3f457171dcde477ff6575b578835f1fd519 (64 Bit)]

GPoint(Object)>>doesNotUnderstand: #,
	Receiver: a GPoint(5,10)
	Arguments and temporary variables: 
		aMessage: 	, 11
		exception: 	Instance of GPoint did not understand #,
		resumeValue: 	nil
	Receiver's instance variables: 
		coordinates: 	(5,10)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	array := 5 , 10 , 11 , 9 , 3 , 8 , 3 , 6 , 2 , 1 , 8 , 6 , 12 , 7
	...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	array := 5 , 10 , 11 , 9 , 3 , 8 , 3 , 6 , 2 , 1 , 8 , 6 , 12 , 7
	...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'array := (5, 10, 11, 9, 3, 8, 3, 6, 2, 1, 8, 6, 12, 7, 13, 9, 1, 7, 1...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#array->#(5 #, 10 #, 11 #, 9 #, 3 #, 8 #, 3 #, 6 #, 2...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (2336 to: 2544) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| tests results array|

"
These test cases ass...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#array->#(5 #, 10 #, 11 #, 9 #, 3 #, 8 #, 3 #, 6 #, 2...etc...
		aString: 	'array := (5, 10, 11, 9, 3, 8, 3, 6, 2, 1, 8, 6, 12, 7, 13, 9, 1, 7, 1...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (2336 to: 2544) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| tests results array|

"
These test cases ass...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'array := (5, 10, 11, 9, 3, 8, 3, 6, 2, 1, 8, 6, 12, 7, 13, 9, 1, 7, 1...etc...
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'array := (5, 10, 11, 9, 3, 8, 3, 6, 2, 1, 8, 6, 12, 7, 13, 9, 1, 7,...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurTHERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 6
24 February 2023 9:19:10.739 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.536.sha.2314c3f457171dcde477ff6575b578835f1fd519 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #(#(1 1 1 1 13 13 13 13 12 12 12 12 11 11 11 11 10 10 10 10 9 9 9 9 8 8 8 8 7 7 7 7 6 6 6 ...etc...
	Arguments and temporary variables: 
		index: 	6
	Receiver's instance variables: 
#(#(1 1 1 1 13 13 13 13 12 12 12 12 11 11 11 11 10 10 10 10 9 9 9 9 8 8 8 8 7 7 7 7 6 6 6 ...etc...

Array(Object)>>at:
	Receiver: #(#(1 1 1 1 13 13 13 13 12 12 12 12 11 11 11 11 10 10 10 10 9 9 9 9 8 8 8 8 7 7 7 7 6 6 6 ...etc...
	Arguments and temporary variables: 
		index: 	6
	Receiver's instance variables: 
#(#(1 1 1 1 13 13 13 13 12 12 12 12 11 11 11 11 10 10 10 10 9 9 9 9 8 8 8 8 7 7 7 7 6 6 6 ...etc...

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		tests: 	#(#(1 1 1 1 13 13 13 13 11 11 11 11 12 12 12 12 10 10 10 10 9 9 9 9 7 7 ...etc...
		results: 	#(#(1 1 1 1 13 13 13 13 12 12 12 12 11 11 11 11 10 10 10 10 9 9 9 9 8 ...etc...
		array1: 	nil
		case1: 	nil
		i: 	6
		shuffling: 	#(5 10 11 9 3 8 3 6 2 1 8 6 12 7 13 9 1 7 10 11 5 12 13 4 2 4 2 8 3 ...etc...
		should_be: 	nil
		you_said: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| tests results array1 case1 |
	"
These test cases assume that the ...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| tests results array1 case1 |
	"
These test cases assume that the ...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'| tests results array1 case1|

"
These test cases assume that the TOP...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#array->#(5 10 11 9 3 8 3 6 2 1 8 6 12 7 13 9 1 7 10 ...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 2696) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| tests results array1 case1|

"
These test ca...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#array->#(5 10 11 9 3 8 3 6 2 1 8 6 12 7 13 9 1 7 10 ...etc...
		aString: 	'| tests results array1 case1|

"
These test cases assume that the TOP...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 2696) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| tests results array1 case1|

"
These test ca...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand name...etc...
		startpc: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(72545792))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(72545792)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		event: 	[(34@29) mouseUp 12167536 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		evt: 	[(34@29) mouseUp 12167536 nil]
		all: 	an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216)...etc...
		m: 	a SpToolbarButtonMorph(72545792)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216) a SpToolbarButt...etc...
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216) a SpToolbarButt...etc...

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		evt: 	[(34@29) mouseUp 12167536 nil]
		all: 	an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216)...etc...
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(34@29) mouseUp 12167536 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(34@29) mouseUp 12167536 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(72545792)
	Receiver's instance variables: 
		timeStamp: 	12167536
		source: 	a HandMorph(284116480)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(34@29)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(34@29) mouseUp 12167536 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(34@29) mouseUp 12167536 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(850@159) mouseUp 12167536 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(1048330240) [world]
		transformedEvent: 	[(34@29) mouseUp 12167536 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(850@159.0) corner: (866@175.0)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(850@159.0) corner: (866@175.0)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(850@159) mouseUp 12167536 nil]
		targetOffset: 	(34.0@24.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(284116480)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(1048330240) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(850@159) mouseUp 12167536 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(1048330240) [world]
		transformedEvent: 	[(34@29) mouseUp 12167536 nil]
	Receiver's instance variables: 
		bounds: 	(850@159.0) corner: (866@175.0)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(850@159.0) corner: (866@175.0)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(850@159) mouseUp 12167536 nil]
		targetOffset: 	(34.0@24.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(850@159) mouseUp 12167536 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(850@159.0) corner: (866@175.0)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(850@159.0) corner: (866@175.0)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(850@159) mouseUp 12167536 nil]
		targetOffset: 	(34.0@24.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(850@159) mouseUp 12167536 nil]
	Receiver's instance variables: 
		bounds: 	(850@159.0) corner: (866@175.0)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(850@159.0) corner: (866@175.0)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(850@159) mouseUp 12167536 nil]
		targetOffset: 	(34.0@24.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(850@159) mouseUp 12167536 nil]
		evt: 	[(850@159) mouseUp 12167536 nil]
	Receiver's instance variables: 
		bounds: 	(850@159.0) corner: (866@175.0)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(850@159.0) corner: (866@175.0)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(850@159) mouseUp 12167536 nil]
		targetOffset: 	(34.0@24.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(850@159) mouseUp 12167536 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(1048330240) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(1048330240) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(284116480))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11906893
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(827456000)))
		lastAlarmTime: 	12167516
		activeHand: 	a HandMorph(284116480)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1536@841)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(1048330240) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(284116480))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11906893
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(827456000)))
		lastAlarmTime: 	12167516
		activeHand: 	a HandMorph(284116480)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1536@841)


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(10...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			    ...etc...
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		startpc: 	a CompiledBlock: [ 
		| extraWorldsToDraw |
		extraWorldsToDraw := Ext...etc...
		numArgs: 	0
		receiver: 	WorldMorph



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 6
24 February 2023 9:19:11.054 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.536.sha.2314c3f457171dcde477ff6575b578835f1fd519 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #(#(1 1 1 1 13 13 13 13 12 12 12 12 11 11 11 11 10 10 10 10 9 9 9 9 8 8 8 8 7 7 7 7 6 6 6 ...etc...
	Arguments and temporary variables: 
		index: 	6
	Receiver's instance variables: 
#(#(1 1 1 1 13 13 13 13 12 12 12 12 11 11 11 11 10 10 10 10 9 9 9 9 8 8 8 8 7 7 7 7 6 6 6 ...etc...

Array(Object)>>at:
	Receiver: #(#(1 1 1 1 13 13 13 13 12 12 12 12 11 11 11 11 10 10 10 10 9 9 9 9 8 8 8 8 7 7 7 7 6 6 6 ...etc...
	Arguments and temporary variables: 
		index: 	6
	Receiver's instance variables: 
#(#(1 1 1 1 13 13 13 13 12 12 12 12 11 11 11 11 10 10 10 10 9 9 9 9 8 8 8 8 7 7 7 7 6 6 6 ...etc...

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		tests: 	#(#(1 1 1 1 13 13 13 13 11 11 11 11 12 12 12 12 10 10 10 10 9 9 9 9 7 7 ...etc...
		results: 	#(#(1 1 1 1 13 13 13 13 12 12 12 12 11 11 11 11 10 10 10 10 9 9 9 9 8 ...etc...
		array1: 	nil
		case1: 	nil
		i: 	6
		shuffling: 	#(5 10 11 9 3 8 3 6 2 1 8 6 12 7 13 9 1 7 10 11 5 12 13 4 2 4 2 8 3 ...etc...
		should_be: 	nil
		you_said: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| tests results array1 case1 |
	"
These test cases assume that the ...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| tests results array1 case1 |
	"
These test cases assume that the ...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'| tests results array1 case1|

"
These test cases assume that the TOP...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#array->#(5 10 11 9 3 8 3 6 2 1 8 6 12 7 13 9 1 7 10 ...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 2696) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| tests results array1 case1|

"
These test ca...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#array->#(5 10 11 9 3 8 3 6 2 1 8 6 12 7 13 9 1 7 10 ...etc...
		aString: 	'| tests results array1 case1|

"
These test cases assume that the TOP...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 2696) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| tests results array1 case1|

"
These test ca...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		p<<error during printing>>

FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand name...etc...
		startpc: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(72545792))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(72545792)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		event: 	[(34@29) mouseUp 12167536 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		evt: 	[(34@29) mouseUp 12167536 nil]
		all: 	an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216)...etc...
		m: 	a SpToolbarButtonMorph(72545792)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216) a SpToolbarButt...etc...
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216) a SpToolbarButt...etc...

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		evt: 	[(34@29) mouseUp 12167536 nil]
		all: 	an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216)...etc...
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(34@29) mouseUp 12167536 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(34@29) mouseUp 12167536 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(72545792)
	Receiver's instance variables: 
		timeStamp: 	12167536
		source: 	a HandMorph(284116480)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(34@29)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(34@29) mouseUp 12167536 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(34@29) mouseUp 12167536 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(850@159) mouseUp 12167536 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(1048330240) [world]
		transformedEvent: 	[(34@29) mouseUp 12167536 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(850@159.0) corner: (866@175.0)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(850@159.0) corner: (866@175.0)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(850@159) mouseUp 12167536 nil]
		targetOffset: 	(34.0@24.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(284116480)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(1048330240) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(850@159) mouseUp 12167536 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(1048330240) [world]
		transformedEvent: 	[(34@29) mouseUp 12167536 nil]
	Receiver's instance variables: 
		bounds: 	(850@159.0) corner: (866@175.0)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(850@159.0) corner: (866@175.0)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(850@159) mouseUp 12167536 nil]
		targetOffset: 	(34.0@24.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(850@159) mouseUp 12167536 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(850@159.0) corner: (866@175.0)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(850@159.0) corner: (866@175.0)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(850@159) mouseUp 12167536 nil]
		targetOffset: 	(34.0@24.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(850@159) mouseUp 12167536 nil]
	Receiver's instance variables: 
		bounds: 	(850@159.0) corner: (866@175.0)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(850@159.0) corner: (866@175.0)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(850@159) mouseUp 12167536 nil]
		targetOffset: 	(34.0@24.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(850@159) mouseUp 12167536 nil]
		evt: 	[(850@159) mouseUp 12167536 nil]
	Receiver's instance variables: 
		bounds: 	(850@159.0) corner: (866@175.0)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(850@159.0) corner: (866@175.0)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(850@159) mouseUp 12167536 nil]
		targetOffset: 	(34.0@24.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(850@159) mouseUp 12167536 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(1048330240) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(1048330240) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(284116480))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11906893
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(827456000)))
		lastAlarmTime: 	12167516
		activeHand: 	a HandMorph(284116480)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1536@841)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(1048330240) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(284116480))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11906893
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(827456000)))
		lastAlarmTime: 	12167516
		activeHand: 	a HandMorph(284116480)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1536@841)


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(10...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			    ...etc...
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		startpc: 	a CompiledBlock: [ 
		| extraWorldsToDraw |
		extraWorldsToDraw := Ext...etc...
		numArgs: 	0
		receiver: 	WorldMorph



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#withIndexDo: was sent to nil
24 February 2023 9:19:36.574 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.536.sha.2314c3f457171dcde477ff6575b578835f1fd519 (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #withIndexDo:
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	withIndexDo: [:card :index | "deal the cards to the two piles"
    (i...etc...
		exception: 	#withIndexDo: was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #withIndexDo:
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	withIndexDo: [:card :index | "deal the cards to the two piles"
    (i...etc...
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

War class>>deal:
	Receiver: War
	Arguments and temporary variables: 
		pile1: 	an OrderedCollection()
		pile2: 	an OrderedCollection()
		aDeck: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#War
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#WAR


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		tests: 	#(#(1 1 1 1 13 13 13 13 11 11 11 11 12 12 12 12 10 10 10 10 9 9 9 9 7 7 ...etc...
		results: 	#(#(1 1 1 1 13 13 13 13 12 12 12 12 11 11 11 11 10 10 10 10 9 9 9 9 8 ...etc...
		array1: 	nil
		case1: 	nil
		i: 	1
		shuffling: 	nil
		should_be: 	nil
		you_said: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| tests results array1 case1 |
	"
These test cases assume that the ...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| tests results array1 case1 |
	"
These test cases assume that the ...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'| tests results array1 case1|

"
These test cases assume that the TOP...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#array->#(5 10 11 9 3 8 3 6 2 1 8 6 12 7 13 9 1 7 10 ...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 2698) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| tests results array1 case1|

"
These test ca...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#array->#(5 10 11 9 3 8 3 6 2 1 8 6 12 7 13 9 1 7 10 ...etc...
		aString: 	'| tests results array1 case1|

"
These test cases assume that the TOP...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 2698) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| tests results array1 case1|

"
These test ca...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand name...etc...
		startpc: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(72545792))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(72545792)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		event: 	[(30@29) mouseUp 12193372 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		evt: 	[(30@29) mouseUp 12193372 nil]
		all: 	an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216)...etc...
		m: 	a SpToolbarButtonMorph(72545792)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216) a SpToolbarButt...etc...
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216) a SpToolbarButt...etc...

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		evt: 	[(30@29) mouseUp 12193372 nil]
		all: 	an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216)...etc...
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(30@29) mouseUp 12193372 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(30@29) mouseUp 12193372 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(72545792)
	Receiver's instance variables: 
		timeStamp: 	12193372
		source: 	a HandMorph(284116480)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(30@29)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(30@29) mouseUp 12193372 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(30@29) mouseUp 12193372 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(846@159) mouseUp 12193372 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(1048330240) [world]
		transformedEvent: 	[(30@29) mouseUp 12193372 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(846@159.0) corner: (862@175.0)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(846@159.0) corner: (862@175.0)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(846@159) mouseUp 12193372 nil]
		targetOffset: 	(30.0@24.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(284116480)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(1048330240) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(846@159) mouseUp 12193372 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(1048330240) [world]
		transformedEvent: 	[(30@29) mouseUp 12193372 nil]
	Receiver's instance variables: 
		bounds: 	(846@159.0) corner: (862@175.0)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(846@159.0) corner: (862@175.0)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(846@159) mouseUp 12193372 nil]
		targetOffset: 	(30.0@24.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(846@159) mouseUp 12193372 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(846@159.0) corner: (862@175.0)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(846@159.0) corner: (862@175.0)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(846@159) mouseUp 12193372 nil]
		targetOffset: 	(30.0@24.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(846@159) mouseUp 12193372 nil]
	Receiver's instance variables: 
		bounds: 	(846@159.0) corner: (862@175.0)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(846@159.0) corner: (862@175.0)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(846@159) mouseUp 12193372 nil]
		targetOffset: 	(30.0@24.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(846@159) mouseUp 12193372 nil]
		evt: 	[(846@159) mouseUp 12193372 nil]
	Receiver's instance variables: 
		bounds: 	(846@159.0) corner: (862@175.0)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(846@159.0) corner: (862@175.0)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(846@159) mouseUp 12193372 nil]
		targetOffset: 	(30.0@24.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(846@159) mouseUp 12193372 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(1048330240) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(1048330240) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(284116480))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11906893
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(827456000)))
		lastAlarmTime: 	12193351
		activeHand: 	a HandMorph(284116480)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1536@841)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(1048330240) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(284116480))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11906893
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(827456000)))
		lastAlarmTime: 	12193351
		activeHand: 	a HandMorph(284116480)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1536@841)


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(10...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #withIndexDo:
UndefinedObject>>doesNotUnderstand: #withIndexDo:
War class>>deal:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#withIndexDo: was sent to nil
24 February 2023 9:19:36.873 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.536.sha.2314c3f457171dcde477ff6575b578835f1fd519 (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #withIndexDo:
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	withIndexDo: [:card :index | "deal the cards to the two piles"
    (i...etc...
		exception: 	#withIndexDo: was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #withIndexDo:
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	withIndexDo: [:card :index | "deal the cards to the two piles"
    (i...etc...
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

War class>>deal:
	Receiver: War
	Arguments and temporary variables: 
		pile1: 	an OrderedCollection()
		pile2: 	an OrderedCollection()
		aDeck: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#War
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#WAR


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		tests: 	#(#(1 1 1 1 13 13 13 13 11 11 11 11 12 12 12 12 10 10 10 10 9 9 9 9 7 7 ...etc...
		results: 	#(#(1 1 1 1 13 13 13 13 12 12 12 12 11 11 11 11 10 10 10 10 9 9 9 9 8 ...etc...
		array1: 	nil
		case1: 	nil
		i: 	1
		shuffling: 	nil
		should_be: 	nil
		you_said: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| tests results array1 case1 |
	"
These test cases assume that the ...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| tests results array1 case1 |
	"
These test cases assume that the ...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'| tests results array1 case1|

"
These test cases assume that the TOP...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#array->#(5 10 11 9 3 8 3 6 2 1 8 6 12 7 13 9 1 7 10 ...etc...
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 2698) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| tests results array1 case1|

"
These test ca...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#array->#(5 10 11 9 3 8 3 6 2 1 8 6 12 7 13 9 1 7 10 ...etc...
		aString: 	'| tests results array1 case1|

"
These test cases assume that the TOP...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 2698) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '| tests results array1 case1|

"
These test ca...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand name...etc...
		startpc: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(72<<error during printing>>

SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		event: 	[(30@29) mouseUp 12193372 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		evt: 	[(30@29) mouseUp 12193372 nil]
		all: 	an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216)...etc...
		m: 	a SpToolbarButtonMorph(72545792)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216) a SpToolbarButt...etc...
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216) a SpToolbarButt...etc...

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		evt: 	[(30@29) mouseUp 12193372 nil]
		all: 	an Array(a SpToolbarButtonMorph(72545792) a SpToolbarButtonMorph(77097216)...etc...
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(30@29) mouseUp 12193372 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(30@29) mouseUp 12193372 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(72545792)
	Receiver's instance variables: 
		timeStamp: 	12193372
		source: 	a HandMorph(284116480)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(30@29)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(30@29) mouseUp 12193372 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(72545792)
	Arguments and temporary variables: 
		anEvent: 	[(30@29) mouseUp 12193372 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(584189440)
		submorphs: 	an Array(an AlignmentMorph(724094720))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (857885184) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(275108352)'Do it'
		iconMorph: 	an ImageMorph(570958848)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(846@159) mouseUp 12193372 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(1048330240) [world]
		transformedEvent: 	[(30@29) mouseUp 12193372 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(846@159.0) corner: (862@175.0)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(846@159.0) corner: (862@175.0)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(846@159) mouseUp 12193372 nil]
		targetOffset: 	(30.0@24.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(284116480)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(1048330240) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(846@159) mouseUp 12193372 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(1048330240) [world]
		transformedEvent: 	[(30@29) mouseUp 12193372 nil]
	Receiver's instance variables: 
		bounds: 	(846@159.0) corner: (862@175.0)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(846@159.0) corner: (862@175.0)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(846@159) mouseUp 12193372 nil]
		targetOffset: 	(30.0@24.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(846@159) mouseUp 12193372 nil]
		focusHolder: 	a SpToolbarButtonMorph(72545792)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(846@159.0) corner: (862@175.0)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(846@159.0) corner: (862@175.0)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(846@159) mouseUp 12193372 nil]
		targetOffset: 	(30.0@24.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(846@159) mouseUp 12193372 nil]
	Receiver's instance variables: 
		bounds: 	(846@159.0) corner: (862@175.0)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(846@159.0) corner: (862@175.0)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(846@159) mouseUp 12193372 nil]
		targetOffset: 	(30.0@24.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(284116480)
	Arguments and temporary variables: 
		anEvent: 	[(846@159) mouseUp 12193372 nil]
		evt: 	[(846@159) mouseUp 12193372 nil]
	Receiver's instance variables: 
		bounds: 	(846@159.0) corner: (862@175.0)
		owner: 	a WorldMorph(1048330240) [world]
		submorphs: 	#()
		fullBounds: 	(846@159.0) corner: (862@175.0)
		color: 	Color blue
		extension: 	a MorphExtension (666700800)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(651665920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(846@159) mouseUp 12193372 nil]
		targetOffset: 	(30.0@24.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(846@159) mouseUp 12193372 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(1048330240) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(1048330240) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(284116480))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11906893
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(827456000)))
		lastAlarmTime: 	12193351
		activeHand: 	a HandMorph(284116480)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1536@841)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(1048330240) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(284116480))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	11906893
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(827456000)))
		lastAlarmTime: 	12193351
		activeHand: 	a HandMorph(284116480)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1536@841)


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(1048330240) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1536@841)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(347660032) a TaskbarMorph(74734592) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1536@841)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (862515456) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(10...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #withIndexDo:
UndefinedObject>>doesNotUnderstand: #withIndexDo:
War class>>deal:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
FullBlockClosure(BlockClosure)>>on:do:
24 February 2023 9:34:10.881 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.536.sha.2314c3f457171dcde477ff6575b578835f1fd519 (64 Bit)]

FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [NumberParser parse: stream]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[:err | self scannerError: err messageText]
	Receiver's instance variables: 
		outerContext: 	RBScanner>>scanNumber
		startpc: 	a CompiledBlock: [NumberParser parse: stream]
		numArgs: 	0
		receiver: 	a RBScanner


RBScanner>>scanNumber
	Receiver: a RBScanner
	Arguments and temporary variables: 
		start: 	80516
		number: 	nil
		stop: 	nil
		string: 	nil
	Receiver's instance variables: 
		stream: 	a ReadStream
		buffer: 	a WriteStream
		tokenStart: 	80516
		currentCharacter: 	$4
		characterType: 	#digit
		classificationTable: 	#(nil nil nil nil nil nil nil nil #separator #separator ni...etc...
		comments: 	an OrderedCollection()
		errorBlock: 	[ :aString :position :parser| parser parseErrorNode: aString ]


RBScanner>>scanToken
	Receiver: a RBScanner
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		stream: 	a ReadStream
		buffer: 	a WriteStream
		tokenStart: 	80516
		currentCharacter: 	$4
		characterType: 	#digit
		classificationTable: 	#(nil nil nil nil nil nil nil nil #separator #separator ni...etc...
		comments: 	an OrderedCollection()
		errorBlock: 	[ :aString :position :parser| parser parseErrorNode: aString ]


RBScanner>>next
	Receiver: a RBScanner
	Arguments and temporary variables: 
		token: 	nil
	Receiver's instance variables: 
		stream: 	a ReadStream
		buffer: 	a WriteStream
		tokenStart: 	80516
		currentCharacter: 	$4
		characterType: 	#digit
		classificationTable: 	#(nil nil nil nil nil nil nil nil #separator #separator ni...etc...
		comments: 	an OrderedCollection()
		errorBlock: 	[ :aString :position :parser| parser parseErrorNode: aString ]


RBParser>>scannerNext
	Receiver: a RBParser
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBNumberLiteralToken(10)
		nextToken: 	nil
		errorBlock: 	[ :aString :position :parser| parser parseErrorNode: aString ]
		source: 	'Initial pile1: #(4 13 9 7 6 10 14 7 4 3 6 8 14 12 2 13 6 11 9 7 6 10 1...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil


RBParser>>step
	Receiver: a RBParser
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBNumberLiteralToken(10)
		nextToken: 	nil
		errorBlock: 	[ :aString :position :parser| parser parseErrorNode: aString ]
		source: 	'Initial pile1: #(4 13 9 7 6 10 14 7 4 3 6 8 14 12 2 13 6 11 9 7 6 10 1...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil


RBParser>>parseNumberLiteral
	Receiver: a RBParser
	Arguments and temporary variables: 
		token: 	 RBNumberLiteralToken(10)
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBNumberLiteralToken(10)
		nextToken: 	nil
		errorBlock: 	[ :aString :position :parser| parser parseErrorNode: aString ]
		source: 	'Initial pile1: #(4 13 9 7 6 10 14 7 4 3 6 8 14 12 2 13 6 11 9 7 6 10 1...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil


RBParser>>parsePrimitiveLiteral
	Receiver: a RBParser
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBNumberLiteralToken(10)
		nextToken: 	nil
		errorBlock: 	[ :aString :position :parser| parser parseErrorNode: aString ]
		source: 	'Initial pile1: #(4 13 9 7 6 10 14 7 4 3 6 8 14 12 2 13 6 11 9 7 6 10 1...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil


RBParser>>parseLiteralArrayObject
	Receiver: a RBParser
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBNumberLiteralToken(10)
		nextToken: 	nil
		errorBlock: 	[ :aString :position :parser| parser parseErrorNode: aString ]
		source: 	'Initial pile1: #(4 13 9 7 6 10 14 7 4 3 6 8 14 12 2 13 6 11 9 7 6 10 1...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil


RBParser>>parseLiteralArray
	Receiver: a RBParser
	Arguments and temporary variables: 
		literals: 	an OrderedCollection(RBLiteralValueNode(2) RBLiteralValueNode(13) RBL...etc...
		startToken: 	 RBLiteralArrayToken('#(')
		stop: 	nil
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBNumberLiteralToken(10)
		nextToken: 	nil
		errorBlock: 	[ :aString :position :parser| parser parseErrorNode: aString ]
		source: 	'Initial pile1: #(4 13 9 7 6 10 14 7 4 3 6 8 14 12 2 13 6 11 9 7 6 10 1...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil


RBParser>>parsePrimitiveObject
	Receiver: a RBParser
	Arguments and temporary variables: 
		errorNode: 	nil
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBNumberLiteralToken(10)
		nextToken: 	nil
		errorBlock: 	[ :aString :position :parser| parser parseErrorNode: aString ]
		source: 	'Initial pile1: #(4 13 9 7 6 10 14 7 4 3 6 8 14 12 2 13 6 11 9 7 6 10 1...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil


RBParser>>parseUnaryMessage
	Receiver: a RBParser
	Arguments and temporary variables: 
		node: 	nil
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBNumberLiteralToken(10)
		nextToken: 	nil
		errorBlock: 	[ :aString :position :parser| parser parseErrorNode: aString ]
		source: 	'Initial pile1: #(4 13 9 7 6 10 14 7 4 3 6 8 14 12 2 13 6 11 9 7 6 10 1...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil


RBParser>>parseBinaryMessage
	Receiver: a RBParser
	Arguments and temporary variables: 
		node: 	nil
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBNumberLiteralToken(10)
		nextToken: 	nil
		errorBlock: 	[ :aString :position :parser| parser parseErrorNode: aString ]
		source: 	'Initial pile1: #(4 13 9 7 6 10 14 7 4 3 6 8 14 12 2 13 6 11 9 7 6 10 1...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil


RBParser>>parseKeywordMessageWith:
	Receiver: a RBParser
	Arguments and temporary variables: 
		node: 	RBLiteralValueNode(8)
		args: 	an OrderedCollection()
		isKeyword: 	false
		keywordsStartPositions: 	an OrderedCollection(80429)
		selector: 	RBSelectorNode(pile1:)
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBNumberLiteralToken(10)
		nextToken: 	nil
		errorBlock: 	[ :aString :position :parser| parser parseErrorNode: aString ]
		source: 	'Initial pile1: #(4 13 9 7 6 10 14 7 4 3 6 8 14 12 2 13 6 11 9 7 6 10 1...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil


RBParser>>parseKeywordMessage
	Receiver: a RBParser
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBNumberLiteralToken(10)
		nextToken: 	nil
		errorBlock: 	[ :aString :position :parser| parser parseErrorNode: aString ]
		source: 	'Initial pile1: #(4 13 9 7 6 10 14 7 4 3 6 8 14 12 2 13 6 11 9 7 6 10 1...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil


RBParser>>parseCascadeMessage
	Receiver: a RBParser
	Arguments and temporary variables: 
		node: 	nil
		receiver: 	nil
		messages: 	nil
		semicolons: 	nil
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBNumberLiteralToken(10)
		nextToken: 	nil
		errorBlock: 	[ :aString :position :parser| parser parseErrorNode: aString ]
		source: 	'Initial pile1: #(4 13 9 7 6 10 14 7 4 3 6 8 14 12 2 13 6 11 9 7 6 10 1...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil


RBParser>>parseAssignment
	Receiver: a RBParser
	Arguments and temporary variables: 
		node: 	nil
		position: 	nil
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBNumberLiteralToken(10)
		nextToken: 	nil
		errorBlock: 	[ :aString :position :parser| parser parseErrorNode: aString ]
		source: 	'Initial pile1: #(4 13 9 7 6 10 14 7 4 3 6 8 14 12 2 13 6 11 9 7 6 10 1...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil


RBParser>>parseStatementInto:periodList:withAcceptedStatementClosers:
	Receiver: a RBParser
	Arguments and temporary variables: 
		statementList: 	an OrderedCollection(RBUnfinishedStatementErrorNode( Initial
	pi...etc...
		periods: 	an OrderedCollection()
		aCollectionOfClosers: 	#()
		returnPosition: 	nil
		node: 	nil
		startOfStatementToken: 	 RBNumberLiteralToken(8)
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBNumberLiteralToken(10)
		nextToken: 	nil
		errorBlock: 	[ :aString :position :parser| parser parseErrorNode: aString ]
		source: 	'Initial pile1: #(4 13 9 7 6 10 14 7 4 3 6 8 14 12 2 13 6 11 9 7 6 10 1...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil


RBParser>>parseStatementList:into:untilAnyCloserOf:
	Receiver: a RBParser
	Arguments and temporary variables: 
		pragmaBoolean: 	false
		sequenceNode: 	RBSequenceNode( Initial
	pile1:
		#( 4 13 9 7 6 10 14 7 4 3 6 8 1...etc...
		aCollectionOfClosers: 	#()
		statements: 	an OrderedCollection(RBUnfinishedStatementErrorNode( Initial
	pile1...etc...
		return: 	false
		periods: 	an OrderedCollection()
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBNumberLiteralToken(10)
		nextToken: 	nil
		errorBlock: 	[ :aString :position :parser| parser parseErrorNode: aString ]
		source: 	'Initial pile1: #(4 13 9 7 6 10 14 7 4 3 6 8 14 12 2 13 6 11 9 7 6 10 1...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil


RBParser>>parseStatements:into:untilAnyCloserOf:
	Receiver: a RBParser
	Arguments and temporary variables: 
		pragmaBoolean: 	false
		aSequenceNode: 	RBSequenceNode( Initial
	pile1:
		#( 4 13 9 7 6 10 14 7 4 3 6 8 ...etc...
		aCollectionOfClosers: 	#()
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBNumberLiteralToken(10)
		nextToken: 	nil
		errorBlock: 	[ :aString :position :parser| parser parseErrorNode: aString ]
		source: 	'Initial pile1: #(4 13 9 7 6 10 14 7 4 3 6 8 14 12 2 13 6 11 9 7 6 10 1...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil


RBParser>>parseStatements:
	Receiver: a RBParser
	Arguments and temporary variables: 
		pragmaBoolean: 	false
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBNumberLiteralToken(10)
		nextToken: 	nil
		errorBlock: 	[ :aString :position :parser| parser parseErrorNode: aString ]
		source: 	'Initial pile1: #(4 13 9 7 6 10 14 7 4 3 6 8 14 12 2 13 6 11 9 7 6 10 1...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil


RBParser>>parseExpression
	Receiver: a RBParser
	Arguments and temporary variables: 
		node: 	nil
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBNumberLiteralToken(10)
		nextToken: 	nil
		errorBlock: 	[ :aString :position :parser| parser parseErrorNode: aString ]
		source: 	'Initial pile1: #(4 13 9 7 6 10 14 7 4 3 6 8 14 12 2 13 6 11 9 7 6 10 1...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil


RBParser class>>parseExpression:onError:
	Receiver: RBParser
	Arguments and temporary variables: 
		aString: 	'Initial pile1: #(4 13 9 7 6 10 14 7 4 3 6 8 14 12 2 13 6 11 9 7 6 10 ...etc...
		aBlock: 	[ :aString :position :parser| parser parseErrorNode: aString ]
		node: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#addCommentsTo:->RBParser>>#addCommentsTo: #addP...etc...
		format: 	65543
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{RBPatternParser. OCTargetCompilerParser}
		name: 	#RBParser
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'AST-Core-Parser'


RBParser class>>parseFaultyExpression:
	Receiver: RBParser
	Arguments and temporary variables: 
		aString: 	'Initial pile1: #(4 13 9 7 6 10 14 7 4 3 6 8 14 12 2 13 6 11 9 7 6 10 ...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#addCommentsTo:->RBParser>>#addCommentsTo: #addP...etc...
		format: 	65543
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{RBPatternParser. OCTargetCompilerParser}
		name: 	#RBParser
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'AST-Core-Parser'


[ 
		RBParser parseFaultyExpression: self textArea string] in [node := RBParser parseMethod: self textArea string onError: [ 
		RBParser parseFaultyExpression: self textArea string]
	] in RubSmalltalkEditor>>bestNodeInTextArea
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		start: 	129545
		stop: 	129667
		node: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->a Dictionary(Key BACKSP...etc...
		textArea: 	a RubEditingArea(215414016)
		notificationStrategy: 	a RubTextInsertionStrategy
		completionEngine: 	a CoCompletionEngine


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
		RBParser parseFaultyExpression: self textArea string]
	Arguments and temporary variables: 
		anArg: 	'End of statement expected'
	Receiver's instance variables: 
		outerContext: 	[node := RBParser parseMethod: self textArea string onError: [ 
	...etc...
		startpc: 	a CompiledBlock: [ 
		RBParser parseFaultyExpression: self textArea st...etc...
		numArgs: 	0
		receiver: 	a RubSmalltalkEditor


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
		RBParser parseFaultyExpression: self textArea string]
	Arguments and temporary variables: 
		firstArg: 	'End of statement expected'
		secondArg: 	8383
	Receiver's instance variables: 
		outerContext: 	[node := RBParser parseMethod: self textArea string onError: [ 
	...etc...
		startpc: 	a CompiledBlock: [ 
		RBParser parseFaultyExpression: self textArea st...etc...
		numArgs: 	0
		receiver: 	a RubSmalltalkEditor


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
		RBParser parseFaultyExpression: self textArea string]
	Arguments and temporary variables: 
		firstArg: 	'End of statement expected'
		secondArg: 	8383
		thirdArg: 	a RBParser
	Receiver's instance variables: 
		outerContext: 	[node := RBParser parseMethod: self textArea string onError: [ 
	...etc...
		startpc: 	a CompiledBlock: [ 
		RBParser parseFaultyExpression: self textArea st...etc...
		numArgs: 	0
		receiver: 	a RubSmalltalkEditor


RBParser>>parserError:
	Receiver: a RBParser
	Arguments and temporary variables: 
		aString: 	'End of statement expected'
		errorNode: 	nil
		errorMessage: 	nil
		errorPosition: 	nil
		newSource: 	nil
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBNumberLiteralToken(2)
		nextToken: 	nil
		errorBlock: 	[ 
		RBParser parseFaultyExpression: self textArea string]
		source: 	'Initial pile1: #(4 13 9 7 6 10 14 7 4 3 6 8 14 12 2 13 6 11 9 7 6 10 1...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil


RBParser>>parseStatementInto:periodList:withAcceptedStatementClosers:
	Receiver: a RBParser
	Arguments and temporary variables: 
		statementList: 	an OrderedCollection(RBUnfinishedStatementErrorNode(  Initial
	p...etc...
		periods: 	an OrderedCollection()
		aCollectionOfClosers: 	#()
		returnPosition: 	nil
		node: 	RBMessageNode(12 Current card)
		startOfStatementToken: 	 RBNumberLiteralToken(12)
	Receiver's instance variables: 
		scanner: 	a RBScanner
		currentToken: 	 RBNumberLiteralToken(2)
		nextToken: 	nil
		errorBlock: 	[ 
		RBParser parseFaultyExpression: self textArea string]
		source: 	'Initial pile1: #(4 13 9 7 6 10 14 7 4 3 6 8 14 12 2 13 6 11 9 7 6 10 1...etc...
		comments: 	an OrderedCollection()
		pragmas: 	nil


RBParser>>parseStatementList:into:untilAnyCloserOf:
	Receiver: a RBParser
	Arguments and temporary variables: 
