'From Pharo10.0.0 of 5 December 2022 [Build information: Pharo-10.0.0+build.536.sha.2314c3f457171dcde477ff6575b578835f1fd519 (64 Bit)] on 3 March 2023 at 10:02:53.457 pm'!Object subclass: #War	instanceVariableNames: ''	classVariableNames: ''	package: 'WAR'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!War class	instanceVariableNames: ''!!War class methodsFor: 'as yet unclassified' stamp: 'Anonymous 3/3/2023 21:56'!deal: aDeck| pile1 pile2 | "pile1 and pile2 are the two piles of cards"pile1 := OrderedCollection new. pile2 := OrderedCollection new. aDeck withIndexDo: [:card :index | "deal the cards to the two piles"    (index odd) ifTrue: [           (card = 1) ifTrue: [ pile1 add: 14 ]  "ace is 14"                   ifFalse: [ pile1 add: card ] ]              ifFalse: [        (card = 1) ifTrue: [ pile2 add: 14 ]                   ifFalse: [ pile2 add: card ] ]].pile1 := pile1 reversed. "reverse the piles so that the first card is the top card"pile2 := pile2 reversed.[(pile1 size > 0) and: [pile2 size > 0]] whileTrue: [      |currentCard1 currentCard2 sortedCards|    sortedCards := SortedCollection new. "cards that are removed from the piles are added"    currentCard1 := pile1 removeFirst.    currentCard2 := pile2 removeFirst.    [currentCard1 = currentCard2] whileTrue: [ "war occurs when the two cards are equal"        sortedCards add: currentCard1.        sortedCards add: currentCard2.			        ((pile1 size > 1) and: [pile2 size > 1]) ifTrue: [ "if there are enough cards in the piles to continue the war"            sortedCards add: pile1 removeFirst.            sortedCards add: pile2 removeFirst. ].            (pile1 size = 0) ifTrue: [ "if there are not enough cards in the piles to continue the war"            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile2 addAll: sortedCards.            ^self winner: pile2 asArray].            (pile2 size = 0) ifTrue: [            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile1 addAll: sortedCards.            ^self winner: pile1 asArray].        currentCard1 := pile1 removeFirst.        currentCard2 := pile2 removeFirst].    (currentCard1 > currentCard2) "if the first card is greater than the second card, player 1 wins"	ifTrue: [        sortedCards add: currentCard1.        sortedCards add: currentCard2.        sortedCards := sortedCards sortBlock: [:a :b | a > b].        pile1 addAll: sortedCards.]	 ifFalse: [                    "if the second card is greater than the first card, player 2 wins"        sortedCards add: currentCard1.        sortedCards add: currentCard2.        sortedCards := sortedCards sortBlock: [:a :b | a > b].        pile2 addAll: sortedCards.].    (pile1 size = 0) ifTrue: [ ^self winner: pile2 asArray]. "if one of the piles is empty, the other player wins"    (pile2 size = 0) ifTrue: [ ^self winner: pile1 asArray].].! !!War class methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 20:07'!winner: pile    | winner |    winner := OrderedCollection new.    pile do: [:card |                 "convert the cards to their original values"        (card = 14) ifTrue: [ winner add: 1]                     ifFalse: [ winner add: card]].		    ^ (winner asArray)! !