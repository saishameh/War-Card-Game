----QUIT----2022-12-05T08:52:59.453604+01:00 Pharo10-SNAPSHOT-64bit-2314c3f.image priorSource: 0!----QUIT----2022-12-05T08:53:28.447671+01:00 Pharo10-SNAPSHOT-64bit-2314c3f.image priorSource: 0!Object subclass: #War	instanceVariableNames: '' 	classVariableNames: ''	package: 'WAR'!!War class methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 18:00'!deal: aDeck| pile1 pile2 winner |pile1 := OrderedCollection new.pile2 := OrderedCollection new.aDeck withIndexDo: [:card :index |    (index odd) ifTrue: [        (card = 1) ifTrue: [ pile1 add: 14 ]                    ifFalse: [ pile1 add: card ] ]              ifFalse: [        (card = 1) ifTrue: [ pile2 add: 14 ]                    ifFalse: [ pile2 add: card ] ]].pile1 := pile1 reversed.pile2 := pile2 reversed.Transcript show: 'Initial pile1: '; show: pile1 asArray; cr.Transcript show: 'Initial pile2: '; show: pile2 asArray; cr. [(pile1 size > 0) and: [pile2 size > 0]] whileTrue: [    |currentCard1 currentCard2 sortedCards|    sortedCards := SortedCollection new.    currentCard1 := pile1 removeFirst.    currentCard2 := pile2 removeFirst.    [currentCard1 = currentCard2] whileTrue: [        sortedCards add: currentCard1.        sortedCards add: currentCard2.        ((pile1 size > 1) and: [pile2 size > 1]) ifTrue: [            sortedCards add: pile1 removeFirst.            sortedCards add: pile2 removeFirst.].            (pile1 size = 0) ifTrue: [            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile2 addAll: sortedCards.            winner pile2 asArray.].            (pile2 size = 0) ifTrue: [            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile1 addAll: sortedCards.            winner pile1 asArray].        currentCard1 := pile1 removeFirst.        currentCard2 := pile2 removeFirst].    (currentCard1 > currentCard2) ifTrue: [        pile1 add: currentCard1.        pile1 add: currentCard2.    ] ifFalse: [        pile2 add: currentCard2.        pile2 add: currentCard1].    (pile1 size = 0) ifTrue: [        winner pile2 asArray].    (pile2 size = 0) ifTrue: [        winner pile1 asArray]].! !!War class methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 18:13'!winner: pile    | winner |    winner := OrderedCollection new.    pile do: [:card |        (card = 14) ifTrue: [ winner add: 1]                    ifFalse: [ winner add: card]].    ^ winner asArray! !!War class methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 18:15' prior: 33554804!deal: aDeck| pile1 pile2 winner |pile1 := OrderedCollection new.pile2 := OrderedCollection new.aDeck withIndexDo: [:card :index |    (index odd) ifTrue: [        (card = 1) ifTrue: [ pile1 add: 14 ]                    ifFalse: [ pile1 add: card ] ]              ifFalse: [        (card = 1) ifTrue: [ pile2 add: 14 ]                    ifFalse: [ pile2 add: card ] ]].pile1 := pile1 reversed.pile2 := pile2 reversed.Transcript show: 'Initial pile1: '; show: pile1 asArray; cr.Transcript show: 'Initial pile2: '; show: pile2 asArray; cr. [(pile1 size > 0) and: [pile2 size > 0]] whileTrue: [    |currentCard1 currentCard2 sortedCards|    sortedCards := SortedCollection new.    currentCard1 := pile1 removeFirst.    currentCard2 := pile2 removeFirst.    [currentCard1 = currentCard2] whileTrue: [        sortedCards add: currentCard1.        sortedCards add: currentCard2.        ((pile1 size > 1) and: [pile2 size > 1]) ifTrue: [            sortedCards add: pile1 removeFirst.            sortedCards add: pile2 removeFirst.].            (pile1 size = 0) ifTrue: [            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile2 addAll: sortedCards.            self winner: pile2 asArray].            (pile2 size = 0) ifTrue: [            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile1 addAll: sortedCards.            self winner: pile1 asArray].        currentCard1 := pile1 removeFirst.        currentCard2 := pile2 removeFirst].    (currentCard1 > currentCard2) ifTrue: [        pile1 add: currentCard1.        pile1 add: currentCard2.    ] ifFalse: [        pile2 add: currentCard2.        pile2 add: currentCard1].    (pile1 size = 0) ifTrue: [self winner: pile2 asArray].    (pile2 size = 0) ifTrue: [self winner: pile1 asArray].].! !!War class methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 18:15' prior: 33557020!deal: aDeck| pile1 pile2 |pile1 := OrderedCollection new.pile2 := OrderedCollection new.aDeck withIndexDo: [:card :index |    (index odd) ifTrue: [        (card = 1) ifTrue: [ pile1 add: 14 ]                    ifFalse: [ pile1 add: card ] ]              ifFalse: [        (card = 1) ifTrue: [ pile2 add: 14 ]                    ifFalse: [ pile2 add: card ] ]].pile1 := pile1 reversed.pile2 := pile2 reversed.Transcript show: 'Initial pile1: '; show: pile1 asArray; cr.Transcript show: 'Initial pile2: '; show: pile2 asArray; cr. [(pile1 size > 0) and: [pile2 size > 0]] whileTrue: [    |currentCard1 currentCard2 sortedCards|    sortedCards := SortedCollection new.    currentCard1 := pile1 removeFirst.    currentCard2 := pile2 removeFirst.    [currentCard1 = currentCard2] whileTrue: [        sortedCards add: currentCard1.        sortedCards add: currentCard2.        ((pile1 size > 1) and: [pile2 size > 1]) ifTrue: [            sortedCards add: pile1 removeFirst.            sortedCards add: pile2 removeFirst.].            (pile1 size = 0) ifTrue: [            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile2 addAll: sortedCards.            self winner: pile2 asArray].            (pile2 size = 0) ifTrue: [            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile1 addAll: sortedCards.            self winner: pile1 asArray].        currentCard1 := pile1 removeFirst.        currentCard2 := pile2 removeFirst].    (currentCard1 > currentCard2) ifTrue: [        pile1 add: currentCard1.        pile1 add: currentCard2.    ] ifFalse: [        pile2 add: currentCard2.        pile2 add: currentCard1].    (pile1 size = 0) ifTrue: [self winner: pile2 asArray].    (pile2 size = 0) ifTrue: [self winner: pile1 asArray].].! !----SNAPSHOT----2023-02-24T18:17:15.59-05:00 finalWar.image priorSource: 99!----SNAPSHOT----2023-02-24T18:17:36.082-05:00 finalWar.image priorSource: 6351!!War class methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 18:23' prior: 33558954!deal: aDeck| pile1 pile2 |pile1 := OrderedCollection new.pile2 := OrderedCollection new.aDeck withIndexDo: [:card :index |    (index odd) ifTrue: [        (card = 1) ifTrue: [ pile1 add: 14 ]                    ifFalse: [ pile1 add: card ] ]              ifFalse: [        (card = 1) ifTrue: [ pile2 add: 14 ]                    ifFalse: [ pile2 add: card ] ]].pile1 := pile1 reversed.pile2 := pile2 reversed.Transcript show: 'Initial pile1: '; show: pile1 asArray; cr.Transcript show: 'Initial pile2: '; show: pile2 asArray; cr. [(pile1 size > 0) and: [pile2 size > 0]] whileTrue: [    |currentCard1 currentCard2 sortedCards|    sortedCards := SortedCollection new.    currentCard1 := pile1 removeFirst.    currentCard2 := pile2 removeFirst.Transcript show: 'Current card 1: '; show: currentCard1; show: ' Current card 2: '; show: currentCard2; cr.    [currentCard1 = currentCard2] whileTrue: [        sortedCards add: currentCard1.        sortedCards add: currentCard2.Transcript show: 'War!! with cards: '; show: currentCard1; show: ' and '; show: currentCard2; cr.        ((pile1 size > 1) and: [pile2 size > 1]) ifTrue: [            sortedCards add: pile1 removeFirst.            sortedCards add: pile2 removeFirst.].            (pile1 size = 0) ifTrue: [            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile2 addAll: sortedCards.            self winner: pile2 asArray].            (pile2 size = 0) ifTrue: [            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile1 addAll: sortedCards.            self winner: pile1 asArray].        currentCard1 := pile1 removeFirst.        currentCard2 := pile2 removeFirst].    (currentCard1 > currentCard2) ifTrue: [        pile1 add: currentCard1.        pile1 add: currentCard2.    ] ifFalse: [        pile2 add: currentCard2.        pile2 add: currentCard1].    (pile1 size = 0) ifTrue: [self winner: pile2 asArray].    (pile2 size = 0) ifTrue: [self winner: pile1 asArray].].! !----SNAPSHOT----2023-02-24T18:23:33.515-05:00 finalWar.image priorSource: 6429!----SNAPSHOT----2023-02-24T18:24:24.398-05:00 finalWar.image priorSource: 8641!!War class methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 18:25' prior: 33561040!deal: aDeck| pile1 pile2 |pile1 := OrderedCollection new.pile2 := OrderedCollection new.aDeck withIndexDo: [:card :index |    (index odd) ifTrue: [        (card = 1) ifTrue: [ pile1 add: 14 ]                    ifFalse: [ pile1 add: card ] ]              ifFalse: [        (card = 1) ifTrue: [ pile2 add: 14 ]                    ifFalse: [ pile2 add: card ] ]].pile1 := pile1 reversed.pile2 := pile2 reversed.Transcript show: 'Initial pile1: '; show: pile1 asArray; cr.Transcript show: 'Initial pile2: '; show: pile2 asArray; cr. [(pile1 size > 0) and: [pile2 size > 0]] whileTrue: [    |currentCard1 currentCard2 sortedCards|    sortedCards := SortedCollection new.    currentCard1 := pile1 removeFirst.    currentCard2 := pile2 removeFirst.Transcript show: 'Current card 1: '; show: currentCard1; show: ' Current card 2: '; show: currentCard2; cr.    [currentCard1 = currentCard2] whileTrue: [        sortedCards add: currentCard1.        sortedCards add: currentCard2.Transcript show: 'War!! with cards: '; show: currentCard1; show: ' and '; show: currentCard2; cr.        ((pile1 size > 1) and: [pile2 size > 1]) ifTrue: [            sortedCards add: pile1 removeFirst.            sortedCards add: pile2 removeFirst.Transcript show: 'pile1: '; show: pile1 asArray; cr.Transcript show: 'pile2: '; show: pile2 asArray; cr. ].            (pile1 size = 0) ifTrue: [            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile2 addAll: sortedCards.Transcript show: 'pile1: '; show: pile1 asArray; cr.Transcript show: 'pile2: '; show: pile2 asArray; cr.             self winner: pile2 asArray].            (pile2 size = 0) ifTrue: [            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile1 addAll: sortedCards.Transcript show: 'pile1: '; show: pile1 asArray; cr.Transcript show: 'pile2: '; show: pile2 asArray; cr.             self winner: pile1 asArray].        currentCard1 := pile1 removeFirst.        currentCard2 := pile2 removeFirst].    (currentCard1 > currentCard2) ifTrue: [        pile1 add: currentCard1.        pile1 add: currentCard2.    ] ifFalse: [        pile2 add: currentCard2.        pile2 add: currentCard1].    (pile1 size = 0) ifTrue: [self winner: pile2 asArray].    (pile2 size = 0) ifTrue: [self winner: pile1 asArray].].! !!War class methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 18:38' prior: 33563333!deal: aDeck| pile1 pile2 |pile1 := OrderedCollection new.pile2 := OrderedCollection new.aDeck withIndexDo: [:card :index |    (index odd) ifTrue: [        (card = 1) ifTrue: [ pile1 add: 14 ]                    ifFalse: [ pile1 add: card ] ]              ifFalse: [        (card = 1) ifTrue: [ pile2 add: 14 ]                    ifFalse: [ pile2 add: card ] ]].pile1 := pile1 reversed.pile2 := pile2 reversed.Transcript show: 'Initial pile1: '; show: pile1 asArray; cr.Transcript show: 'Initial pile2: '; show: pile2 asArray; cr. [(pile1 size > 0) and: [pile2 size > 0]] whileTrue: [    |currentCard1 currentCard2 sortedCards|    sortedCards := SortedCollection new.    currentCard1 := pile1 removeFirst.    currentCard2 := pile2 removeFirst.	Transcript show: 'Current card 1: '; show: currentCard1; show: ' Current card 2: '; show: 	currentCard2; cr.    [currentCard1 = currentCard2] whileTrue: [        sortedCards add: currentCard1.        sortedCards add: currentCard2.		  Transcript show: 'War!! with cards: '; show: currentCard1; show: ' and '; show: currentCard2; 			cr.        ((pile1 size > 1) and: [pile2 size > 1]) ifTrue: [            sortedCards add: pile1 removeFirst.            sortedCards add: pile2 removeFirst.				Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr. ].            (pile1 size = 0) ifTrue: [            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile2 addAll: sortedCards.				Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr.             self winner: pile2 asArray].            (pile2 size = 0) ifTrue: [            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile1 addAll: sortedCards.				Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr.             self winner: pile1 asArray].        currentCard1 := pile1 removeFirst.        currentCard2 := pile2 removeFirst].    (currentCard1 > currentCard2) 	ifTrue: [        pile1 add: currentCard1.        pile1 add: currentCard2.		  Transcript show: 'Player 1 wins with cards: '; show: currentCard1; show: ' and '; show: currentCard2; cr.]	 ifFalse: [        pile2 add: currentCard2.        pile2 add: currentCard1.		  Transcript show: 'Player 2 wins with cards: '; show: currentCard2; show: ' and '; show: currentCard1; cr.].    (pile1 size = 0) ifTrue: [self winner: pile2 asArray].    (pile2 size = 0) ifTrue: [self winner: pile1 asArray].].! !!War class methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 18:40' prior: 33565785!deal: aDeck| pile1 pile2 |pile1 := OrderedCollection new.pile2 := OrderedCollection new.aDeck withIndexDo: [:card :index |    (index odd) ifTrue: [        (card = 1) ifTrue: [ pile1 add: 14 ]                    ifFalse: [ pile1 add: card ] ]              ifFalse: [        (card = 1) ifTrue: [ pile2 add: 14 ]                    ifFalse: [ pile2 add: card ] ]].pile1 := pile1 reversed.pile2 := pile2 reversed.Transcript show: 'Initial pile1: '; show: pile1 asArray; cr.Transcript show: 'Initial pile2: '; show: pile2 asArray; cr. [(pile1 size > 0) and: [pile2 size > 0]] whileTrue: [    |currentCard1 currentCard2 sortedCards|    sortedCards := SortedCollection new.    currentCard1 := pile1 removeFirst.    currentCard2 := pile2 removeFirst.	Transcript show: 'Current card 1: '; show: currentCard1; show: ' Current card 2: '; show: 	currentCard2; cr.    [currentCard1 = currentCard2] whileTrue: [        sortedCards add: currentCard1.        sortedCards add: currentCard2.		  Transcript show: 'War!! with cards: '; show: currentCard1; show: ' and '; show: currentCard2; 			cr.        ((pile1 size > 1) and: [pile2 size > 1]) ifTrue: [            sortedCards add: pile1 removeFirst.            sortedCards add: pile2 removeFirst.				Transcript show: 'removed Cards:'; show: sortedCards asArray; cr.				Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr. ].            (pile1 size = 0) ifTrue: [            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile2 addAll: sortedCards.				Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr.             self winner: pile2 asArray].            (pile2 size = 0) ifTrue: [            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile1 addAll: sortedCards.				Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr.             self winner: pile1 asArray].        currentCard1 := pile1 removeFirst.        currentCard2 := pile2 removeFirst].    (currentCard1 > currentCard2) 	ifTrue: [        pile1 add: currentCard1.        pile1 add: currentCard2.		  Transcript show: 'Player 1 wins with cards: '; show: currentCard1; show: ' and '; show: currentCard2; cr.		Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr. ]	 ifFalse: [        pile2 add: currentCard2.        pile2 add: currentCard1.		  Transcript show: 'Player 2 wins with cards: '; show: currentCard2; show: ' and '; show: currentCard1; cr.		Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr. ].    (pile1 size = 0) ifTrue: [self winner: pile2 asArray].    (pile2 size = 0) ifTrue: [self winner: pile1 asArray].].! !!War class methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 18:42' prior: 33568490!deal: aDeck| pile1 pile2 |pile1 := OrderedCollection new.pile2 := OrderedCollection new.aDeck withIndexDo: [:card :index |    (index odd) ifTrue: [        (card = 1) ifTrue: [ pile1 add: 14 ]                    ifFalse: [ pile1 add: card ] ]              ifFalse: [        (card = 1) ifTrue: [ pile2 add: 14 ]                    ifFalse: [ pile2 add: card ] ]].pile1 := pile1 reversed.pile2 := pile2 reversed.Transcript show: 'Initial pile1: '; show: pile1 asArray; cr.Transcript show: 'Initial pile2: '; show: pile2 asArray; cr. [(pile1 size > 0) and: [pile2 size > 0]] whileTrue: [    |currentCard1 currentCard2 sortedCards|    sortedCards := SortedCollection new.    currentCard1 := pile1 removeFirst.    currentCard2 := pile2 removeFirst.	Transcript show: 'Current card 1: '; show: currentCard1; show: ' Current card 2: '; show: 	currentCard2; cr.    [currentCard1 = currentCard2] whileTrue: [        sortedCards add: currentCard1.        sortedCards add: currentCard2.		  Transcript show: 'War!! with cards: '; show: currentCard1; show: ' and '; show: currentCard2; 			cr.        ((pile1 size > 1) and: [pile2 size > 1]) ifTrue: [            sortedCards add: pile1 removeFirst.            sortedCards add: pile2 removeFirst.				Transcript show: 'removed Cards:'; show: sortedCards asArray; cr.				Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr. ].            (pile1 size = 0) ifTrue: [            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile2 addAll: sortedCards.				Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr.             self winner: pile2 asArray].            (pile2 size = 0) ifTrue: [            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile1 addAll: sortedCards.				Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr.             self winner: pile1 asArray].        currentCard1 := pile1 removeFirst.        currentCard2 := pile2 removeFirst].    (currentCard1 > currentCard2) 	ifTrue: [        pile1 add: currentCard1.        pile1 add: currentCard2.		  pile1 addAll: sortedCards.		  Transcript show: 'Player 1 wins with cards: '; show: currentCard1; show: ' and '; show: currentCard2; cr.		Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr. ]	 ifFalse: [        pile2 add: currentCard2.        pile2 add: currentCard1.        pile2 addAll: sortedCards.		  Transcript show: 'Player 2 wins with cards: '; show: currentCard2; show: ' and '; show: currentCard1; cr.		Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr. ].    (pile1 size = 0) ifTrue: [self winner: pile2 asArray].    (pile2 size = 0) ifTrue: [self winner: pile1 asArray].].! !!War class methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 18:51' prior: 33571491!deal: aDeck| pile1 pile2 |pile1 := OrderedCollection new.pile2 := OrderedCollection new.aDeck withIndexDo: [:card :index |    (index odd) ifTrue: [        (card = 1) ifTrue: [ pile1 add: 14 ]                    ifFalse: [ pile1 add: card ] ]              ifFalse: [        (card = 1) ifTrue: [ pile2 add: 14 ]                    ifFalse: [ pile2 add: card ] ]].pile1 := pile1 reversed.pile2 := pile2 reversed.Transcript show: 'Initial pile1: '; show: pile1 asArray; cr.Transcript show: 'Initial pile2: '; show: pile2 asArray; cr. [(pile1 size > 0) and: [pile2 size > 0]] whileTrue: [    |currentCard1 currentCard2 sortedCards|    sortedCards := SortedCollection new.    currentCard1 := pile1 removeFirst.    currentCard2 := pile2 removeFirst.	Transcript show: 'Current card 1: '; show: currentCard1; show: ' Current card 2: '; show: 	currentCard2; cr.    [currentCard1 = currentCard2] whileTrue: [        sortedCards add: currentCard1.        sortedCards add: currentCard2.		  Transcript show: 'War!! with cards: '; show: currentCard1; show: ' and '; show: currentCard2; 			cr.        ((pile1 size > 1) and: [pile2 size > 1]) ifTrue: [            sortedCards add: pile1 removeFirst.            sortedCards add: pile2 removeFirst.				Transcript show: 'removed Cards:'; show: sortedCards asArray; cr.				Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr. ].            (pile1 size = 0) ifTrue: [            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile2 addAll: sortedCards.				Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr.             self winner: pile2 asArray].            (pile2 size = 0) ifTrue: [            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile1 addAll: sortedCards.				Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr.             self winner: pile1 asArray].        currentCard1 := pile1 removeFirst.        currentCard2 := pile2 removeFirst].    (currentCard1 > currentCard2) 	ifTrue: [        sortedCards add: currentCard1.        sortedCards add: currentCard2.        sortedCards := sortedCards sortBlock: [:a :b | a > b].        pile1 addAll: sortedCards.		  Transcript show: 'Player 1 wins with cards: '; show: currentCard1; show: ' and '; show: currentCard2; cr.		Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr. ]	 ifFalse: [        sortedCards add: currentCard1.        sortedCards add: currentCard2.        sortedCards := sortedCards sortBlock: [:a :b | a > b].        pile2 addAll: sortedCards.		  Transcript show: 'Player 2 wins with cards: '; show: currentCard2; show: ' and '; show: currentCard1; cr.		Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr. ].    (pile1 size = 0) ifTrue: [self winner: pile2 asArray].    (pile2 size = 0) ifTrue: [self winner: pile1 asArray].].! !!War class methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 18:53' prior: 33574558!deal: aDeck| pile1 pile2 |pile1 := OrderedCollection new.pile2 := OrderedCollection new.aDeck withIndexDo: [:card :index |    (index odd) ifTrue: [        (card = 1) ifTrue: [ pile1 add: 14 ]                    ifFalse: [ pile1 add: card ] ]              ifFalse: [        (card = 1) ifTrue: [ pile2 add: 14 ]                    ifFalse: [ pile2 add: card ] ]].pile1 := pile1 reversed.pile2 := pile2 reversed.Transcript show: 'Initial pile1: '; show: pile1 asArray; cr.Transcript show: 'Initial pile2: '; show: pile2 asArray; cr. [(pile1 size > 0) and: [pile2 size > 0]] whileTrue: [    |currentCard1 currentCard2 sortedCards|    sortedCards := SortedCollection new.    currentCard1 := pile1 removeFirst.    currentCard2 := pile2 removeFirst.	Transcript show: 'Current card 1: '; show: currentCard1; show: ' Current card 2: '; show: 	currentCard2; cr.    [currentCard1 = currentCard2] whileTrue: [        sortedCards add: currentCard1.        sortedCards add: currentCard2.		  Transcript show: 'War!! with cards: '; show: currentCard1; show: ' and '; show: currentCard2; 			cr.        ((pile1 size > 1) and: [pile2 size > 1]) ifTrue: [            sortedCards add: pile1 removeFirst.            sortedCards add: pile2 removeFirst.				Transcript show: 'removed Cards:'; show: sortedCards asArray; cr.				Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr. ].            (pile1 size = 0) ifTrue: [            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile2 addAll: sortedCards.				Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr.             self winner: pile2 asArray].            (pile2 size = 0) ifTrue: [            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile1 addAll: sortedCards.				Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr.             self winner: pile1 asArray].        currentCard1 := pile1 removeFirst.        currentCard2 := pile2 removeFirst].    (currentCard1 > currentCard2) 	ifTrue: [        sortedCards add: currentCard1.        sortedCards add: currentCard2.        sortedCards := sortedCards sortBlock: [:a :b | a < b].        pile1 addAll: sortedCards.		  Transcript show: 'Player 1 wins with cards: '; show: currentCard1; show: ' and '; show: currentCard2; cr.		Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr. ]	 ifFalse: [        sortedCards add: currentCard1.        sortedCards add: currentCard2.        sortedCards := sortedCards sortBlock: [:a :b | a < b].        pile2 addAll: sortedCards.		  Transcript show: 'Player 2 wins with cards: '; show: currentCard2; show: ' and '; show: currentCard1; cr.		Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr. ].    (pile1 size = 0) ifTrue: [self winner: pile2 asArray].    (pile2 size = 0) ifTrue: [self winner: pile1 asArray].].! !!War class methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 19:03' prior: 33556716!winner: pile    | winner |    winner := OrderedCollection new.    pile do: [:card |        (card = 14) ifTrue: [ winner add: 1]                    ifFalse: [ winner add: card]].		 Transcript show: 'this is the winner array:'; show: winner.    ^ winner asArray! !!War class methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 19:14' prior: 33577779!deal: aDeck| pile1 pile2 |pile1 := OrderedCollection new.pile2 := OrderedCollection new.aDeck withIndexDo: [:card :index |    (index odd) ifTrue: [        (card = 1) ifTrue: [ pile1 add: 14 ]                    ifFalse: [ pile1 add: card ] ]              ifFalse: [        (card = 1) ifTrue: [ pile2 add: 14 ]                    ifFalse: [ pile2 add: card ] ]].pile1 := pile1 reversed.pile2 := pile2 reversed.Transcript show: 'Initial pile1: '; show: pile1 asArray; cr.Transcript show: 'Initial pile2: '; show: pile2 asArray; cr. [(pile1 size > 0) and: [pile2 size > 0]] whileTrue: [    |currentCard1 currentCard2 sortedCards|    sortedCards := SortedCollection new.    currentCard1 := pile1 removeFirst.    currentCard2 := pile2 removeFirst.	Transcript show: 'Current card 1: '; show: currentCard1; show: ' Current card 2: '; show: 	currentCard2; cr.    [currentCard1 = currentCard2] whileTrue: [        sortedCards add: currentCard1.        sortedCards add: currentCard2.		  Transcript show: 'War!! with cards: '; show: currentCard1; show: ' and '; show: currentCard2; 			cr.        ((pile1 size > 1) and: [pile2 size > 1]) ifTrue: [            sortedCards add: pile1 removeFirst.            sortedCards add: pile2 removeFirst.				Transcript show: 'removed Cards:'; show: sortedCards asArray; cr.				Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr. ].            (pile1 size = 0) ifTrue: [            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile2 addAll: sortedCards.				Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr.             self winner: pile2 asArray].            (pile2 size = 0) ifTrue: [            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile1 addAll: sortedCards.				Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr.             self winner: pile1 asArray].        currentCard1 := pile1 removeFirst.        currentCard2 := pile2 removeFirst].    (currentCard1 > currentCard2) 	ifTrue: [        sortedCards add: currentCard1.        sortedCards add: currentCard2.        pile1 addAll: sortedCards.		  Transcript show: 'Player 1 wins with cards: '; show: currentCard1; show: ' and '; show: currentCard2; cr.		Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr. ]	 ifFalse: [        sortedCards add: currentCard1.        sortedCards add: currentCard2.        pile2 addAll: sortedCards.		  Transcript show: 'Player 2 wins with cards: '; show: currentCard2; show: ' and '; show: currentCard1; cr.		Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr. ].    (pile1 size = 0) ifTrue: [self winner: pile2 asArray].    (pile2 size = 0) ifTrue: [self winner: pile1 asArray].].! !!War class methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 19:15' prior: 33581368!deal: aDeck| pile1 pile2 |pile1 := OrderedCollection new.pile2 := OrderedCollection new.aDeck withIndexDo: [:card :index |    (index odd) ifTrue: [        (card = 1) ifTrue: [ pile1 add: 14 ]                    ifFalse: [ pile1 add: card ] ]              ifFalse: [        (card = 1) ifTrue: [ pile2 add: 14 ]                    ifFalse: [ pile2 add: card ] ]].pile1 := pile1 reversed.pile2 := pile2 reversed.Transcript show: 'Initial pile1: '; show: pile1 asArray; cr.Transcript show: 'Initial pile2: '; show: pile2 asArray; cr. [(pile1 size > 0) and: [pile2 size > 0]] whileTrue: [    |currentCard1 currentCard2 sortedCards|    sortedCards := SortedCollection new.    currentCard1 := pile1 removeFirst.    currentCard2 := pile2 removeFirst.	Transcript show: 'Current card 1: '; show: currentCard1; show: ' Current card 2: '; show: 	currentCard2; cr.    [currentCard1 = currentCard2] whileTrue: [        sortedCards add: currentCard1.        sortedCards add: currentCard2.		  Transcript show: 'War!! with cards: '; show: currentCard1; show: ' and '; show: currentCard2; 			cr.        ((pile1 size > 1) and: [pile2 size > 1]) ifTrue: [            sortedCards add: pile1 removeFirst.            sortedCards add: pile2 removeFirst.				Transcript show: 'removed Cards:'; show: sortedCards asArray; cr.				Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr. ].            (pile1 size = 0) ifTrue: [            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile2 addAll: sortedCards.				Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr.             self winner: pile2 asArray].            (pile2 size = 0) ifTrue: [            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile1 addAll: sortedCards.				Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr.             self winner: pile1 asArray].        currentCard1 := pile1 removeFirst.        currentCard2 := pile2 removeFirst].    (currentCard1 > currentCard2) 	ifTrue: [        sortedCards add: currentCard1.        sortedCards add: currentCard2.sortedCards := sortedCards sortBlock: [:a :b | a > b].        pile1 addAll: sortedCards.		  Transcript show: 'Player 1 wins with cards: '; show: currentCard1; show: ' and '; show: currentCard2; cr.		Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr. ]	 ifFalse: [        sortedCards add: currentCard1.        sortedCards add: currentCard2.        pile2 addAll: sortedCards.		  Transcript show: 'Player 2 wins with cards: '; show: currentCard2; show: ' and '; show: currentCard1; cr.		Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr. ].    (pile1 size = 0) ifTrue: [self winner: pile2 asArray].    (pile2 size = 0) ifTrue: [self winner: pile1 asArray].].! !!War class methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 19:18' prior: 33581000!winner: pile    | winner |    winner := OrderedCollection new.    pile do: [:card |        (card = 14) ifTrue: [ winner add: 1]                    ifFalse: [ winner add: card]].		    ^ winner asArray! !!War class methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 19:27' prior: 33584463!deal: aDeck| pile1 pile2 |pile1 := OrderedCollection new.pile2 := OrderedCollection new.aDeck withIndexDo: [:card :index |    (index odd) ifTrue: [        (card = 1) ifTrue: [ pile1 add: 14 ]                    ifFalse: [ pile1 add: card ] ]              ifFalse: [        (card = 1) ifTrue: [ pile2 add: 14 ]                    ifFalse: [ pile2 add: card ] ]].pile1 := pile1 reversed.pile2 := pile2 reversed.Transcript show: 'Initial pile1: '; show: pile1 asArray; cr.Transcript show: 'Initial pile2: '; show: pile2 asArray; cr. [(pile1 size > 0) and: [pile2 size > 0]] whileTrue: [    |currentCard1 currentCard2 sortedCards|    sortedCards := SortedCollection new.    currentCard1 := pile1 removeFirst.    currentCard2 := pile2 removeFirst.	Transcript show: 'Current card 1: '; show: currentCard1; show: ' Current card 2: '; show: 	currentCard2; cr.    [currentCard1 = currentCard2] whileTrue: [        sortedCards add: currentCard1.        sortedCards add: currentCard2.		  Transcript show: 'War!! with cards: '; show: currentCard1; show: ' and '; show: currentCard2; 			cr.        ((pile1 size > 1) and: [pile2 size > 1]) ifTrue: [            sortedCards add: pile1 removeFirst.            sortedCards add: pile2 removeFirst.				Transcript show: 'removed Cards:'; show: sortedCards asArray; cr.				Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr. ].            (pile1 size = 0) ifTrue: [            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile2 addAll: sortedCards.				Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr.             ^self winner: pile2 asArray].            (pile2 size = 0) ifTrue: [            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile1 addAll: sortedCards.				Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr.             ^self winner: pile1 asArray].        currentCard1 := pile1 removeFirst.        currentCard2 := pile2 removeFirst].    (currentCard1 > currentCard2) 	ifTrue: [        sortedCards add: currentCard1.        sortedCards add: currentCard2.sortedCards := sortedCards sortBlock: [:a :b | a > b].        pile1 addAll: sortedCards.		  Transcript show: 'Player 1 wins with cards: '; show: currentCard1; show: ' and '; show: currentCard2; cr.		Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr. ]	 ifFalse: [        sortedCards add: currentCard1.        sortedCards add: currentCard2.        pile2 addAll: sortedCards.		  Transcript show: 'Player 2 wins with cards: '; show: currentCard2; show: ' and '; show: currentCard1; cr.		Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr. ].    (pile1 size = 0) ifTrue: [^self winner: pile2 asArray].    (pile2 size = 0) ifTrue: [^self winner: pile1 asArray].].! !!War class methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 19:28' prior: 33587921!deal: aDeck| pile1 pile2 |pile1 := OrderedCollection new.pile2 := OrderedCollection new.aDeck withIndexDo: [:card :index |    (index odd) ifTrue: [        (card = 1) ifTrue: [ pile1 add: 14 ]                    ifFalse: [ pile1 add: card ] ]              ifFalse: [        (card = 1) ifTrue: [ pile2 add: 14 ]                    ifFalse: [ pile2 add: card ] ]].pile1 := pile1 reversed.pile2 := pile2 reversed.Transcript show: 'Initial pile1: '; show: pile1 asArray; cr.Transcript show: 'Initial pile2: '; show: pile2 asArray; cr. [(pile1 size > 0) and: [pile2 size > 0]] whileTrue: [    |currentCard1 currentCard2 sortedCards|    sortedCards := SortedCollection new.    currentCard1 := pile1 removeFirst.    currentCard2 := pile2 removeFirst.	Transcript show: 'Current card 1: '; show: currentCard1; show: ' Current card 2: '; show: 	currentCard2; cr.    [currentCard1 = currentCard2] whileTrue: [        sortedCards add: currentCard1.        sortedCards add: currentCard2.		  Transcript show: 'War!! with cards: '; show: currentCard1; show: ' and '; show: currentCard2; 			cr.        ((pile1 size > 1) and: [pile2 size > 1]) ifTrue: [            sortedCards add: pile1 removeFirst.            sortedCards add: pile2 removeFirst.				Transcript show: 'removed Cards:'; show: sortedCards asArray; cr.				Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr. ].            (pile1 size = 0) ifTrue: [            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile2 addAll: sortedCards.				Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr.             ^self winner: pile2 asArray].            (pile2 size = 0) ifTrue: [            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile1 addAll: sortedCards.				Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr.             ^self winner: pile1 asArray].        currentCard1 := pile1 removeFirst.        currentCard2 := pile2 removeFirst].    (currentCard1 > currentCard2) 	ifTrue: [        sortedCards add: currentCard1.        sortedCards add: currentCard2.sortedCards := sortedCards sortBlock: [:a :b | a > b].        pile1 addAll: sortedCards.		  Transcript show: 'Player 1 wins with cards: '; show: currentCard1; show: ' and '; show: currentCard2; cr.		Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr. ]	 ifFalse: [        sortedCards add: currentCard1.        sortedCards add: currentCard2.sortedCards := sortedCards sortBlock: [:a :b | a > b].        pile2 addAll: sortedCards.		  Transcript show: 'Player 2 wins with cards: '; show: currentCard2; show: ' and '; show: currentCard1; cr.		Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr. ].    (pile1 size = 0) ifTrue: [^self winner: pile2 asArray].    (pile2 size = 0) ifTrue: [^self winner: pile1 asArray].].! !!War class methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 19:28' prior: 33587613!winner: pile    | winner |    winner := OrderedCollection new.    pile do: [:card |        (card = 14) ifTrue: [ winner add: 1]                    ifFalse: [ winner add: card]].		    ^ (winner asArray)! !!War class methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 19:32' prior: 33591075!deal: aDeck| pile1 pile2 |pile1 := OrderedCollection new.pile2 := OrderedCollection new.aDeck withIndexDo: [:card :index |    (index odd) ifTrue: [        (card = 1) ifTrue: [ pile1 add: 14 ]                    ifFalse: [ pile1 add: card ] ]              ifFalse: [        (card = 1) ifTrue: [ pile2 add: 14 ]                    ifFalse: [ pile2 add: card ] ]].pile1 := pile1 reversed.pile2 := pile2 reversed."Transcript show: 'Initial pile1: '; show: pile1 asArray; cr.Transcript show: 'Initial pile2: '; show: pile2 asArray; cr. "[(pile1 size > 0) and: [pile2 size > 0]] whileTrue: [    |currentCard1 currentCard2 sortedCards|    sortedCards := SortedCollection new.    currentCard1 := pile1 removeFirst.    currentCard2 := pile2 removeFirst.	"Transcript show: 'Current card 1: '; show: currentCard1; show: ' Current card 2: '; show: 	currentCard2; cr."    [currentCard1 = currentCard2] whileTrue: [        sortedCards add: currentCard1.        sortedCards add: currentCard2.		  "Transcript show: 'War!! with cards: '; show: currentCard1; show: ' and '; show: currentCard2; 			cr."        ((pile1 size > 1) and: [pile2 size > 1]) ifTrue: [            sortedCards add: pile1 removeFirst.            sortedCards add: pile2 removeFirst.				"Transcript show: 'removed Cards:'; show: sortedCards asArray; cr.				Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr." ].            (pile1 size = 0) ifTrue: [            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile2 addAll: sortedCards.				"Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr. "            ^self winner: pile2 asArray].            (pile2 size = 0) ifTrue: [            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile1 addAll: sortedCards.				"Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr. "            ^self winner: pile1 asArray].        currentCard1 := pile1 removeFirst.        currentCard2 := pile2 removeFirst].    (currentCard1 > currentCard2) 	ifTrue: [        sortedCards add: currentCard1.        sortedCards add: currentCard2.sortedCards := sortedCards sortBlock: [:a :b | a > b].        pile1 addAll: sortedCards.		  "Transcript show: 'Player 1 wins with cards: '; show: currentCard1; show: ' and '; show: currentCard2; cr.		Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr." ]	 ifFalse: [        sortedCards add: currentCard1.        sortedCards add: currentCard2.sortedCards := sortedCards sortBlock: [:a :b | a > b].        pile2 addAll: sortedCards.		  "Transcript show: 'Player 2 wins with cards: '; show: currentCard2; show: ' and '; show: currentCard1; cr.		Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr." ].    (pile1 size = 0) ifTrue: [^self winner: pile2 asArray].    (pile2 size = 0) ifTrue: [^self winner: pile1 asArray].].! !!War class methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 20:07' prior: 33594594!deal: aDeck| pile1 pile2 | "pile1 and pile2 are the two piles of cards"pile1 := OrderedCollection new. pile2 := OrderedCollection new. aDeck withIndexDo: [:card :index | "deal the cards to the two piles"    (index odd) ifTrue: [           (card = 1) ifTrue: [ pile1 add: 14 ]  "ace is 14"                   ifFalse: [ pile1 add: card ] ]              ifFalse: [        (card = 1) ifTrue: [ pile2 add: 14 ]                   ifFalse: [ pile2 add: card ] ]].pile1 := pile1 reversed. "reverse the piles so that the first card is the top card"pile2 := pile2 reversed.[(pile1 size > 0) and: [pile2 size > 0]] whileTrue: [      |currentCard1 currentCard2 sortedCards|    sortedCards := SortedCollection new. "cards that are removed from the piles are added"    currentCard1 := pile1 removeFirst.    currentCard2 := pile2 removeFirst.    [currentCard1 = currentCard2] whileTrue: [ "war occurs when the two cards are equal"        sortedCards add: currentCard1.        sortedCards add: currentCard2.        ((pile1 size > 1) and: [pile2 size > 1]) ifTrue: [ "if there are enough cards in the piles to continue the war"            sortedCards add: pile1 removeFirst.            sortedCards add: pile2 removeFirst. ].            (pile1 size = 0) ifTrue: [ "if there are not enough cards in the piles to continue the war"            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile2 addAll: sortedCards.            ^self winner: pile2 asArray].            (pile2 size = 0) ifTrue: [            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile1 addAll: sortedCards.            ^self winner: pile1 asArray].        currentCard1 := pile1 removeFirst.        currentCard2 := pile2 removeFirst].    (currentCard1 > currentCard2) "if the first card is greater than the second card, player 1 wins"	ifTrue: [        sortedCards add: currentCard1.        sortedCards add: currentCard2.        sortedCards := sortedCards sortBlock: [:a :b | a > b].        pile1 addAll: sortedCards.]	 ifFalse: [                    "if the second card is greater than the first card, player 2 wins"        sortedCards add: currentCard1.        sortedCards add: currentCard2.        sortedCards := sortedCards sortBlock: [:a :b | a > b].        pile2 addAll: sortedCards.].    (pile1 size = 0) ifTrue: [^self winner: pile2 asArray]. "if one of the piles is empty, the other player wins"    (pile2 size = 0) ifTrue: [^self winner: pile1 asArray].].! !!War class methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 20:07' prior: 33594284!winner: pile    | winner |    winner := OrderedCollection new.    pile do: [:card |                 "convert the cards to their original values"        (card = 14) ifTrue: [ winner add: 1]                     ifFalse: [ winner add: card]].		    ^ (winner asArray)! !!War class methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 21:09' prior: 33597819!deal: aDeck| pile1 pile2 | "pile1 and pile2 are the two piles of cards"pile1 := OrderedCollection new. pile2 := OrderedCollection new. aDeck withIndexDo: [:card :index | "deal the cards to the two piles"    (index odd) ifTrue: [           (card = 1) ifTrue: [ pile1 add: 14 ]  "ace is 14"                   ifFalse: [ pile1 add: card ] ]              ifFalse: [        (card = 1) ifTrue: [ pile2 add: 14 ]                   ifFalse: [ pile2 add: card ] ]].pile1 := pile1 reversed. "reverse the piles so that the first card is the top card"pile2 := pile2 reversed."Transcript show: 'Initial pile1: '; show: pile1 asArray; cr.Transcript show: 'Initial pile2: '; show: pile2 asArray; cr. "[(pile1 size > 0) and: [pile2 size > 0]] whileTrue: [      |currentCard1 currentCard2 sortedCards|    sortedCards := SortedCollection new. "cards that are removed from the piles are added"    currentCard1 := pile1 removeFirst.    currentCard2 := pile2 removeFirst."Transcript show: 'Current card 1: '; show: currentCard1; show: ' Current card 2: '; show: 	currentCard2; cr."    [currentCard1 = currentCard2] whileTrue: [ "war occurs when the two cards are equal"        sortedCards add: currentCard1.        sortedCards add: currentCard2.		  "Transcript show: 'War!! with cards: '; show: currentCard1; show: ' and '; show: currentCard2; 			cr."					        ((pile1 size > 1) and: [pile2 size > 1]) ifTrue: [ "if there are enough cards in the piles to continue the war"            sortedCards add: pile1 removeFirst.            sortedCards add: pile2 removeFirst. "Transcript show: 'removed Cards:'; show: sortedCards asArray; cr.				Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr."].            (pile1 size = 0) ifTrue: [ "if there are not enough cards in the piles to continue the war"            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile2 addAll: sortedCards.Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr.            ^self winner: pile2 asArray].            (pile2 size = 0) ifTrue: [            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile1 addAll: sortedCards.Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr.             ^self winner: pile1 asArray].        currentCard1 := pile1 removeFirst.        currentCard2 := pile2 removeFirst].    (currentCard1 > currentCard2) "if the first card is greater than the second card, player 1 wins"	ifTrue: [        sortedCards add: currentCard1.        sortedCards add: currentCard2.        sortedCards := sortedCards sortBlock: [:a :b | a > b].        pile1 addAll: sortedCards. "Transcript show: 'Player 1 wins with cards: '; show: currentCard1; show: ' and '; show: currentCard2; cr.		Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr."]	 ifFalse: [                    "if the second card is greater than the first card, player 2 wins"        sortedCards add: currentCard1.        sortedCards add: currentCard2.        sortedCards := sortedCards sortBlock: [:a :b | a > b].        pile2 addAll: sortedCards."Transcript show: 'Player 2 wins with cards: '; show: currentCard2; show: ' and '; show: currentCard1; cr.		Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr." ].    (pile1 size = 0) ifTrue: [^self winner: pile2 asArray]. "if one of the piles is empty, the other player wins"    (pile2 size = 0) ifTrue: [^self winner: pile1 asArray].].! !!War class methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 21:14' prior: 33600800!deal: aDeck| pile1 pile2 | "pile1 and pile2 are the two piles of cards"pile1 := OrderedCollection new. pile2 := OrderedCollection new. aDeck withIndexDo: [:card :index | "deal the cards to the two piles"    (index odd) ifTrue: [           (card = 1) ifTrue: [ pile1 add: 14 ]  "ace is 14"                   ifFalse: [ pile1 add: card ] ]              ifFalse: [        (card = 1) ifTrue: [ pile2 add: 14 ]                   ifFalse: [ pile2 add: card ] ]].pile1 := pile1 reversed. "reverse the piles so that the first card is the top card"pile2 := pile2 reversed.[(pile1 size > 0) and: [pile2 size > 0]] whileTrue: [      |currentCard1 currentCard2 sortedCards|    sortedCards := SortedCollection new. "cards that are removed from the piles are added"    currentCard1 := pile1 removeFirst.    currentCard2 := pile2 removeFirst.    [currentCard1 = currentCard2] whileTrue: [ "war occurs when the two cards are equal"        sortedCards add: currentCard1.        sortedCards add: currentCard2.			        ((pile1 size > 1) and: [pile2 size > 1]) ifTrue: [ "if there are enough cards in the piles to continue the war"            sortedCards add: pile1 removeFirst.            sortedCards add: pile2 removeFirst. ].            (pile1 size = 0) ifTrue: [ "if there are not enough cards in the piles to continue the war"            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile2 addAll: sortedCards.            ^self winner: pile2 asArray].            (pile2 size = 0) ifTrue: [            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile1 addAll: sortedCards.            ^self winner: pile1 asArray].        currentCard1 := pile1 removeFirst.        currentCard2 := pile2 removeFirst].    (currentCard1 > currentCard2) "if the first card is greater than the second card, player 1 wins"	ifTrue: [        sortedCards add: currentCard1.        sortedCards add: currentCard2.        sortedCards := sortedCards sortBlock: [:a :b | a > b].        pile1 addAll: sortedCards.]	 ifFalse: [                    "if the second card is greater than the first card, player 2 wins"        sortedCards add: currentCard1.        sortedCards add: currentCard2.        sortedCards := sortedCards sortBlock: [:a :b | a > b].        pile2 addAll: sortedCards.].    (pile1 size = 0) ifTrue: [^self winner: pile2 asArray]. "if one of the piles is empty, the other player wins"    (pile2 size = 0) ifTrue: [^self winner: pile1 asArray].].! !----SNAPSHOT----2023-02-24T21:22:43.288-05:00 finalWar.image priorSource: 8722!!War class methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 21:28' prior: 33604608!deal: aDeck| pile1 pile2 | "pile1 and pile2 are the two piles of cards"pile1 := OrderedCollection new. pile2 := OrderedCollection new. aDeck withIndexDo: [:card :index | "deal the cards to the two piles"    (index odd) ifTrue: [           (card = 1) ifTrue: [ pile1 add: 14 ]  "ace is 14"                   ifFalse: [ pile1 add: card ] ]              ifFalse: [        (card = 1) ifTrue: [ pile2 add: 14 ]                   ifFalse: [ pile2 add: card ] ]].pile1 := pile1 reversed. "reverse the piles so that the first card is the top card"pile2 := pile2 reversed.Transcript show: 'Initial pile1: '; show: pile1 asArray; cr.Transcript show: 'Initial pile2: '; show: pile2 asArray; cr.[(pile1 size > 0) and: [pile2 size > 0]] whileTrue: [      |currentCard1 currentCard2 sortedCards|    sortedCards := SortedCollection new. "cards that are removed from the piles are added"    currentCard1 := pile1 removeFirst.    currentCard2 := pile2 removeFirst.Transcript show: 'Current card 1: '; show: currentCard1; show: ' Current card 2: '; show: 	currentCard2; cr.    [currentCard1 = currentCard2] whileTrue: [ "war occurs when the two cards are equal"        sortedCards add: currentCard1.        sortedCards add: currentCard2.				Transcript show: 'War!! with cards: '; show: currentCard1; show: ' and '; show: currentCard2; 			cr.	        ((pile1 size > 1) and: [pile2 size > 1]) ifTrue: [ "if there are enough cards in the piles to continue the war"            sortedCards add: pile1 removeFirst.            sortedCards add: pile2 removeFirst.Transcript show: 'removed Cards:'; show: sortedCards asArray; cr.				Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr. ].            (pile1 size = 0) ifTrue: [ "if there are not enough cards in the piles to continue the war"            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile2 addAll: sortedCards.Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr.             ^self winner: pile2 asArray].            (pile2 size = 0) ifTrue: [            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile1 addAll: sortedCards.Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr.             ^self winner: pile1 asArray].        currentCard1 := pile1 removeFirst.        currentCard2 := pile2 removeFirst].    (currentCard1 > currentCard2) "if the first card is greater than the second card, player 1 wins"	ifTrue: [        sortedCards add: currentCard1.        sortedCards add: currentCard2.        sortedCards := sortedCards sortBlock: [:a :b | a > b].        pile1 addAll: sortedCards.Transcript show: 'Player 1 wins with cards: '; show: currentCard1; show: ' and '; show: currentCard2; cr.		Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr.]	 ifFalse: [                    "if the second card is greater than the first card, player 2 wins"        sortedCards add: currentCard1.        sortedCards add: currentCard2.        sortedCards := sortedCards sortBlock: [:a :b | a > b].        pile2 addAll: sortedCards.Transcript show: 'Player 2 wins with cards: '; show: currentCard2; show: ' and '; show: currentCard1; cr.		Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr.].    (pile1 size = 0) ifTrue: [^self winner: pile2 asArray]. "if one of the piles is empty, the other player wins"    (pile2 size = 0) ifTrue: [^self winner: pile1 asArray].].! !!War class methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/24/2023 21:29' prior: 33607302!deal: aDeck| pile1 pile2 | "pile1 and pile2 are the two piles of cards"pile1 := OrderedCollection new. pile2 := OrderedCollection new. aDeck withIndexDo: [:card :index | "deal the cards to the two piles"    (index odd) ifTrue: [           (card = 1) ifTrue: [ pile1 add: 14 ]  "ace is 14"                   ifFalse: [ pile1 add: card ] ]              ifFalse: [        (card = 1) ifTrue: [ pile2 add: 14 ]                   ifFalse: [ pile2 add: card ] ]].pile1 := pile1 reversed. "reverse the piles so that the first card is the top card"pile2 := pile2 reversed.Transcript show: 'Initial pile1: '; show: pile1 asArray; cr.Transcript show: 'Initial pile2: '; show: pile2 asArray; cr.[(pile1 size > 0) and: [pile2 size > 0]] whileTrue: [      |currentCard1 currentCard2 sortedCards|    sortedCards := SortedCollection new. "cards that are removed from the piles are added"    currentCard1 := pile1 removeFirst.    currentCard2 := pile2 removeFirst.Transcript show: 'Current card 1: '; show: currentCard1; show: ' Current card 2: '; show: 	currentCard2; cr.    [currentCard1 = currentCard2] whileTrue: [ "war occurs when the two cards are equal"        sortedCards add: currentCard1.        sortedCards add: currentCard2.				Transcript show: 'War!! with cards: '; show: currentCard1; show: ' and '; show: currentCard2; 			cr; cr.        ((pile1 size > 1) and: [pile2 size > 1]) ifTrue: [ "if there are enough cards in the piles to continue the war"            sortedCards add: pile1 removeFirst.            sortedCards add: pile2 removeFirst.Transcript show: 'removed Cards:'; show: sortedCards asArray; cr.				Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr. ].            (pile1 size = 0) ifTrue: [ "if there are not enough cards in the piles to continue the war"            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile2 addAll: sortedCards.Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr.             ^self winner: pile2 asArray].            (pile2 size = 0) ifTrue: [            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile1 addAll: sortedCards.Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr.             ^self winner: pile1 asArray].        currentCard1 := pile1 removeFirst.        currentCard2 := pile2 removeFirst].    (currentCard1 > currentCard2) "if the first card is greater than the second card, player 1 wins"	ifTrue: [        sortedCards add: currentCard1.        sortedCards add: currentCard2.        sortedCards := sortedCards sortBlock: [:a :b | a > b].        pile1 addAll: sortedCards.Transcript show: 'Player 1 wins with cards: '; show: currentCard1; show: ' and '; show: currentCard2; cr.		Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr.]	 ifFalse: [                    "if the second card is greater than the first card, player 2 wins"        sortedCards add: currentCard1.        sortedCards add: currentCard2.        sortedCards := sortedCards sortBlock: [:a :b | a > b].        pile2 addAll: sortedCards.Transcript show: 'Player 2 wins with cards: '; show: currentCard2; show: ' and '; show: currentCard1; cr.		Transcript show: 'pile1: '; show: pile1 asArray; cr.				Transcript show: 'pile2: '; show: pile2 asArray; cr.].    (pile1 size = 0) ifTrue: [^self winner: pile2 asArray]. "if one of the piles is empty, the other player wins"    (pile2 size = 0) ifTrue: [^self winner: pile1 asArray].].! !----QUIT----2023-02-25T17:16:45.976-05:00 finalWar.image priorSource: 52691!----SNAPSHOT----2023-03-03T21:49:04.357-05:00 finalWar.image priorSource: 60343!!War class methodsFor: 'as yet unclassified' stamp: 'Anonymous 3/3/2023 21:51' prior: 33604608!deal: aDeck| pile1 pile2 | "pile1 and pile2 are the two piles of cards"pile1 := OrderedCollection new. pile2 := OrderedCollection new. aDeck withIndexDo: [:card :index | "deal the cards to the two piles"    (index odd) ifTrue: [           (card = 1) ifTrue: [ pile1 add: 14 ]  "ace is 14"                   ifFalse: [ pile1 add: card ] ]              ifFalse: [        (card = 1) ifTrue: [ pile2 add: 14 ]                   ifFalse: [ pile2 add: card ] ]].pile1 := pile1 reversed. "reverse the piles so that the first card is the top card"pile2 := pile2 reversed.[(pile1 size > 0) and: [pile2 size > 0]] whileTrue: [      |currentCard1 currentCard2 sortedCards|    sortedCards := SortedCollection new. "cards that are removed from the piles are added"    currentCard1 := pile1 removeFirst.    currentCard2 := pile2 removeFirst.    [currentCard1 = currentCard2] whileTrue: [ "war occurs when the two cards are equal"		Transcript show: 'WAAAAR'; cr.        sortedCards add: currentCard1.        sortedCards add: currentCard2.			        ((pile1 size > 1) and: [pile2 size > 1]) ifTrue: [ "if there are enough cards in the piles to continue the war"            sortedCards add: pile1 removeFirst.            sortedCards add: pile2 removeFirst. ].            (pile1 size = 0) ifTrue: [ "if there are not enough cards in the piles to continue the war"            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile2 addAll: sortedCards.	Transcript show: 'player 2 wins!!'; cr.            ^self winner: pile2 asArray].            (pile2 size = 0) ifTrue: [            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile1 addAll: sortedCards.Transcript show: 'player 1 wins!!'; cr.            ^self winner: pile1 asArray].        currentCard1 := pile1 removeFirst.        currentCard2 := pile2 removeFirst].    (currentCard1 > currentCard2) "if the first card is greater than the second card, player 1 wins"	ifTrue: [        sortedCards add: currentCard1.        sortedCards add: currentCard2.        sortedCards := sortedCards sortBlock: [:a :b | a > b].        pile1 addAll: sortedCards.]	 ifFalse: [                    "if the second card is greater than the first card, player 2 wins"        sortedCards add: currentCard1.        sortedCards add: currentCard2.        sortedCards := sortedCards sortBlock: [:a :b | a > b].        pile2 addAll: sortedCards.].    (pile1 size = 0) ifTrue: [Transcript show: 'player 2 wins!!'; cr. ^self winner: pile2 asArray]. "if one of the piles is empty, the other player wins"    (pile2 size = 0) ifTrue: [Transcript show: 'player 1 wins!!'; cr. ^self winner: pile1 asArray].].! !!War class methodsFor: 'as yet unclassified' stamp: 'Anonymous 3/3/2023 21:56' prior: 33615032!deal: aDeck| pile1 pile2 | "pile1 and pile2 are the two piles of cards"pile1 := OrderedCollection new. pile2 := OrderedCollection new. aDeck withIndexDo: [:card :index | "deal the cards to the two piles"    (index odd) ifTrue: [           (card = 1) ifTrue: [ pile1 add: 14 ]  "ace is 14"                   ifFalse: [ pile1 add: card ] ]              ifFalse: [        (card = 1) ifTrue: [ pile2 add: 14 ]                   ifFalse: [ pile2 add: card ] ]].pile1 := pile1 reversed. "reverse the piles so that the first card is the top card"pile2 := pile2 reversed.[(pile1 size > 0) and: [pile2 size > 0]] whileTrue: [      |currentCard1 currentCard2 sortedCards|    sortedCards := SortedCollection new. "cards that are removed from the piles are added"    currentCard1 := pile1 removeFirst.    currentCard2 := pile2 removeFirst.    [currentCard1 = currentCard2] whileTrue: [ "war occurs when the two cards are equal"        sortedCards add: currentCard1.        sortedCards add: currentCard2.			        ((pile1 size > 1) and: [pile2 size > 1]) ifTrue: [ "if there are enough cards in the piles to continue the war"            sortedCards add: pile1 removeFirst.            sortedCards add: pile2 removeFirst. ].            (pile1 size = 0) ifTrue: [ "if there are not enough cards in the piles to continue the war"            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile2 addAll: sortedCards.            ^self winner: pile2 asArray].            (pile2 size = 0) ifTrue: [            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile1 addAll: sortedCards.            ^self winner: pile1 asArray].        currentCard1 := pile1 removeFirst.        currentCard2 := pile2 removeFirst].    (currentCard1 > currentCard2) "if the first card is greater than the second card, player 1 wins"	ifTrue: [        sortedCards add: currentCard1.        sortedCards add: currentCard2.        sortedCards := sortedCards sortBlock: [:a :b | a > b].        pile1 addAll: sortedCards.]	 ifFalse: [                    "if the second card is greater than the first card, player 2 wins"        sortedCards add: currentCard1.        sortedCards add: currentCard2.        sortedCards := sortedCards sortBlock: [:a :b | a > b].        pile2 addAll: sortedCards.].    (pile1 size = 0) ifTrue: [ ^self winner: pile2 asArray]. "if one of the piles is empty, the other player wins"    (pile2 size = 0) ifTrue: [ ^self winner: pile1 asArray].].! !----SNAPSHOT----2023-03-03T21:58:14.112-05:00 finalWar.image priorSource: 60421!----SNAPSHOT----2023-03-03T22:03:08.99-05:00 finalWar.image priorSource: 65923!----QUIT----2023-03-03T22:03:13.339-05:00 finalWar.image priorSource: 66005!!War class methodsFor: 'as yet unclassified' stamp: 'Anonymous 3/4/2023 18:55' prior: 33617838!deal: aDeck| pile1 pile2 | "pile1 and pile2 are the two piles of cards"pile1 := OrderedCollection new. pile2 := OrderedCollection new. aDeck withIndexDo: [:card :index | "deal the cards to the two piles"    (index odd) ifTrue: [           (card = 1) ifTrue: [ pile1 add: 14 ]  "ace is 14"                   ifFalse: [ pile1 add: card ] ]              ifFalse: [        (card = 1) ifTrue: [ pile2 add: 14 ]                   ifFalse: [ pile2 add: card ] ]].pile1 := pile1 reversed. "reverse the piles so that the first card is the top card"pile2 := pile2 reversed.Transcript show: pile1 asArray; cr.Transcript show: pile1 asArray; cr.[(pile1 size > 0) and: [pile2 size > 0]] whileTrue: [      |currentCard1 currentCard2 sortedCards|    sortedCards := SortedCollection new. "cards that are removed from the piles are added"    currentCard1 := pile1 removeFirst.    currentCard2 := pile2 removeFirst.    [currentCard1 = currentCard2] whileTrue: [ "war occurs when the two cards are equal"        sortedCards add: currentCard1.        sortedCards add: currentCard2.			        ((pile1 size > 1) and: [pile2 size > 1]) ifTrue: [ "if there are enough cards in the piles to continue the war"            sortedCards add: pile1 removeFirst.            sortedCards add: pile2 removeFirst. ].            (pile1 size = 0) ifTrue: [ "if there are not enough cards in the piles to continue the war"            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile2 addAll: sortedCards.            ^self winner: pile2 asArray].            (pile2 size = 0) ifTrue: [            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile1 addAll: sortedCards.            ^self winner: pile1 asArray].        currentCard1 := pile1 removeFirst.        currentCard2 := pile2 removeFirst].    (currentCard1 > currentCard2) "if the first card is greater than the second card, player 1 wins"	ifTrue: [        sortedCards add: currentCard1.        sortedCards add: currentCard2.        sortedCards := sortedCards sortBlock: [:a :b | a > b].        pile1 addAll: sortedCards.]	 ifFalse: [                    "if the second card is greater than the first card, player 2 wins"        sortedCards add: currentCard1.        sortedCards add: currentCard2.        sortedCards := sortedCards sortBlock: [:a :b | a > b].        pile2 addAll: sortedCards.].    (pile1 size = 0) ifTrue: [ ^self winner: pile2 asArray]. "if one of the piles is empty, the other player wins"    (pile2 size = 0) ifTrue: [ ^self winner: pile1 asArray].].! !!War class methodsFor: 'as yet unclassified' stamp: 'Anonymous 3/4/2023 18:57' prior: 33620693!deal: aDeck| pile1 pile2 | "pile1 and pile2 are the two piles of cards"pile1 := OrderedCollection new. pile2 := OrderedCollection new. aDeck withIndexDo: [:card :index | "deal the cards to the two piles"    (index odd) ifTrue: [           (card = 1) ifTrue: [ pile1 add: 14 ]  "ace is 14"                   ifFalse: [ pile1 add: card ] ]              ifFalse: [        (card = 1) ifTrue: [ pile2 add: 14 ]                   ifFalse: [ pile2 add: card ] ]].pile1 := pile1 reversed. "reverse the piles so that the first card is the top card"pile2 := pile2 reversed.Transcript show: pile1 asArray; cr.Transcript show: pile2 asArray; cr.[(pile1 size > 0) and: [pile2 size > 0]] whileTrue: [      |currentCard1 currentCard2 sortedCards|    sortedCards := SortedCollection new. "cards that are removed from the piles are added"    currentCard1 := pile1 removeFirst.    currentCard2 := pile2 removeFirst.    [currentCard1 = currentCard2] whileTrue: [ "war occurs when the two cards are equal"        sortedCards add: currentCard1.        sortedCards add: currentCard2.			        ((pile1 size > 1) and: [pile2 size > 1]) ifTrue: [ "if there are enough cards in the piles to continue the war"            sortedCards add: pile1 removeFirst.            sortedCards add: pile2 removeFirst. ].            (pile1 size = 0) ifTrue: [ "if there are not enough cards in the piles to continue the war"            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile2 addAll: sortedCards.            ^self winner: pile2 asArray].            (pile2 size = 0) ifTrue: [            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile1 addAll: sortedCards.            ^self winner: pile1 asArray].        currentCard1 := pile1 removeFirst.        currentCard2 := pile2 removeFirst].    (currentCard1 > currentCard2) "if the first card is greater than the second card, player 1 wins"	ifTrue: [        sortedCards add: currentCard1.        sortedCards add: currentCard2.        sortedCards := sortedCards sortBlock: [:a :b | a > b].        pile1 addAll: sortedCards.]	 ifFalse: [                    "if the second card is greater than the first card, player 2 wins"        sortedCards add: currentCard1.        sortedCards add: currentCard2.        sortedCards := sortedCards sortBlock: [:a :b | a > b].        pile2 addAll: sortedCards.].    (pile1 size = 0) ifTrue: [ ^self winner: pile2 asArray]. "if one of the piles is empty, the other player wins"    (pile2 size = 0) ifTrue: [ ^self winner: pile1 asArray].].! !!War class methodsFor: 'as yet unclassified' stamp: 'Anonymous 3/4/2023 19:07' prior: 33623377!deal: aDeck| pile1 pile2 | "pile1 and pile2 are the two piles of cards"pile1 := OrderedCollection new. pile2 := OrderedCollection new. aDeck withIndexDo: [:card :index | "deal the cards to the two piles"    (index odd) ifTrue: [           (card = 1) ifTrue: [ pile1 add: 14 ]  "ace is 14"                   ifFalse: [ pile1 add: card ] ]              ifFalse: [        (card = 1) ifTrue: [ pile2 add: 14 ]                   ifFalse: [ pile2 add: card ] ]].pile1 := pile1 reversed. "reverse the piles so that the first card is the top card"pile2 := pile2 reversed.Transcript show: pile1 asArray; cr.Transcript show: pile2 asArray; cr.[(pile1 size > 0) and: [pile2 size > 0]] whileTrue: [      |currentCard1 currentCard2 sortedCards|    sortedCards := SortedCollection new. "cards that are removed from the piles are added"    currentCard1 := pile1 removeFirst.    currentCard2 := pile2 removeFirst.	Transcript show: pile1 asArray; cr.	Transcript show: pile2 asArray; cr.    [currentCard1 = currentCard2] whileTrue: [ "war occurs when the two cards are equal"        sortedCards add: currentCard1.        sortedCards add: currentCard2.			        ((pile1 size > 1) and: [pile2 size > 1]) ifTrue: [ "if there are enough cards in the piles to continue the war"            sortedCards add: pile1 removeFirst.            sortedCards add: pile2 removeFirst. ].            (pile1 size = 0) ifTrue: [ "if there are not enough cards in the piles to continue the war"            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile2 addAll: sortedCards.            ^self winner: pile2 asArray].            (pile2 size = 0) ifTrue: [            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile1 addAll: sortedCards.            ^self winner: pile1 asArray].        currentCard1 := pile1 removeFirst.        currentCard2 := pile2 removeFirst].    (currentCard1 > currentCard2) "if the first card is greater than the second card, player 1 wins"	ifTrue: [        sortedCards add: currentCard1.        sortedCards add: currentCard2.        sortedCards := sortedCards sortBlock: [:a :b | a > b].        pile1 addAll: sortedCards.]	 ifFalse: [                    "if the second card is greater than the first card, player 2 wins"        sortedCards add: currentCard1.        sortedCards add: currentCard2.        sortedCards := sortedCards sortBlock: [:a :b | a > b].        pile2 addAll: sortedCards.].    (pile1 size = 0) ifTrue: [ ^self winner: pile2 asArray]. "if one of the piles is empty, the other player wins"    (pile2 size = 0) ifTrue: [ ^self winner: pile1 asArray].].! !!War class methodsFor: 'as yet unclassified' stamp: 'Anonymous 3/4/2023 19:09' prior: 33626061!deal: aDeck| pile1 pile2 | "pile1 and pile2 are the two piles of cards"pile1 := OrderedCollection new. pile2 := OrderedCollection new. aDeck withIndexDo: [:card :index | "deal the cards to the two piles"    (index odd) ifTrue: [           (card = 1) ifTrue: [ pile1 add: 14 ]  "ace is 14"                   ifFalse: [ pile1 add: card ] ]              ifFalse: [        (card = 1) ifTrue: [ pile2 add: 14 ]                   ifFalse: [ pile2 add: card ] ]].pile1 := pile1 reversed. "reverse the piles so that the first card is the top card"pile2 := pile2 reversed.Transcript show: 'Initial pile1: '; show: pile1 asArray; cr.Transcript show: 'Initial pile2: '; show: pile2 asArray; cr.[(pile1 size > 0) and: [pile2 size > 0]] whileTrue: [      |currentCard1 currentCard2 sortedCards|    sortedCards := SortedCollection new. "cards that are removed from the piles are added"    currentCard1 := pile1 removeFirst.    currentCard2 := pile2 removeFirst.	Transcript show: pile1 asArray; cr.	Transcript show: pile2 asArray; cr.    [currentCard1 = currentCard2] whileTrue: [ "war occurs when the two cards are equal"        sortedCards add: currentCard1.        sortedCards add: currentCard2.			        ((pile1 size > 1) and: [pile2 size > 1]) ifTrue: [ "if there are enough cards in the piles to continue the war"            sortedCards add: pile1 removeFirst.            sortedCards add: pile2 removeFirst. ].            (pile1 size = 0) ifTrue: [ "if there are not enough cards in the piles to continue the war"            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile2 addAll: sortedCards.            ^self winner: pile2 asArray].            (pile2 size = 0) ifTrue: [            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile1 addAll: sortedCards.            ^self winner: pile1 asArray].        currentCard1 := pile1 removeFirst.        currentCard2 := pile2 removeFirst].    (currentCard1 > currentCard2) "if the first card is greater than the second card, player 1 wins"	ifTrue: [        sortedCards add: currentCard1.        sortedCards add: currentCard2.        sortedCards := sortedCards sortBlock: [:a :b | a > b].        pile1 addAll: sortedCards.]	 ifFalse: [                    "if the second card is greater than the first card, player 2 wins"        sortedCards add: currentCard1.        sortedCards add: currentCard2.        sortedCards := sortedCards sortBlock: [:a :b | a > b].        pile2 addAll: sortedCards.].    (pile1 size = 0) ifTrue: [ ^self winner: pile2 asArray]. "if one of the piles is empty, the other player wins"    (pile2 size = 0) ifTrue: [ ^self winner: pile1 asArray].].! !!War class methodsFor: 'as yet unclassified' stamp: 'Anonymous 3/4/2023 19:10' prior: 33628819!deal: aDeck| pile1 pile2 | "pile1 and pile2 are the two piles of cards"pile1 := OrderedCollection new. pile2 := OrderedCollection new. aDeck withIndexDo: [:card :index | "deal the cards to the two piles"    (index odd) ifTrue: [           (card = 1) ifTrue: [ pile1 add: 14 ]  "ace is 14"                   ifFalse: [ pile1 add: card ] ]              ifFalse: [        (card = 1) ifTrue: [ pile2 add: 14 ]                   ifFalse: [ pile2 add: card ] ]].pile1 := pile1 reversed. "reverse the piles so that the first card is the top card"pile2 := pile2 reversed.Transcript show: 'Initial pile1: '; show: pile1 asArray; cr.Transcript show: 'Initial pile2: '; show: pile2 asArray; cr; cr.[(pile1 size > 0) and: [pile2 size > 0]] whileTrue: [      |currentCard1 currentCard2 sortedCards|    sortedCards := SortedCollection new. "cards that are removed from the piles are added"    currentCard1 := pile1 removeFirst.    currentCard2 := pile2 removeFirst.	Transcript show: pile1 asArray; cr.	Transcript show: pile2 asArray; cr.    [currentCard1 = currentCard2] whileTrue: [ "war occurs when the two cards are equal"        sortedCards add: currentCard1.        sortedCards add: currentCard2.			        ((pile1 size > 1) and: [pile2 size > 1]) ifTrue: [ "if there are enough cards in the piles to continue the war"            sortedCards add: pile1 removeFirst.            sortedCards add: pile2 removeFirst. ].            (pile1 size = 0) ifTrue: [ "if there are not enough cards in the piles to continue the war"            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile2 addAll: sortedCards.            ^self winner: pile2 asArray].            (pile2 size = 0) ifTrue: [            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile1 addAll: sortedCards.            ^self winner: pile1 asArray].        currentCard1 := pile1 removeFirst.        currentCard2 := pile2 removeFirst].    (currentCard1 > currentCard2) "if the first card is greater than the second card, player 1 wins"	ifTrue: [        sortedCards add: currentCard1.        sortedCards add: currentCard2.        sortedCards := sortedCards sortBlock: [:a :b | a > b].        pile1 addAll: sortedCards.]	 ifFalse: [                    "if the second card is greater than the first card, player 2 wins"        sortedCards add: currentCard1.        sortedCards add: currentCard2.        sortedCards := sortedCards sortBlock: [:a :b | a > b].        pile2 addAll: sortedCards.].    (pile1 size = 0) ifTrue: [ ^self winner: pile2 asArray]. "if one of the piles is empty, the other player wins"    (pile2 size = 0) ifTrue: [ ^self winner: pile1 asArray].].! !!War class methodsFor: 'as yet unclassified' stamp: 'Anonymous 3/4/2023 19:11' prior: 33631627!deal: aDeck| pile1 pile2 | "pile1 and pile2 are the two piles of cards"pile1 := OrderedCollection new. pile2 := OrderedCollection new. aDeck withIndexDo: [:card :index | "deal the cards to the two piles"    (index odd) ifTrue: [           (card = 1) ifTrue: [ pile1 add: 14 ]  "ace is 14"                   ifFalse: [ pile1 add: card ] ]              ifFalse: [        (card = 1) ifTrue: [ pile2 add: 14 ]                   ifFalse: [ pile2 add: card ] ]].pile1 := pile1 reversed. "reverse the piles so that the first card is the top card"pile2 := pile2 reversed.Transcript show: 'Initial pile1: '; show: pile1 asArray; cr.Transcript show: 'Initial pile2: '; show: pile2 asArray; cr; cr.[(pile1 size > 0) and: [pile2 size > 0]] whileTrue: [      |currentCard1 currentCard2 sortedCards|    sortedCards := SortedCollection new. "cards that are removed from the piles are added"    currentCard1 := pile1 removeFirst.    currentCard2 := pile2 removeFirst.	Transcript show: 'pile1: '; show: pile1 asArray; cr.	Transcript show: 'pile2: ';show: pile2 asArray; cr; cr.    [currentCard1 = currentCard2] whileTrue: [ "war occurs when the two cards are equal"        sortedCards add: currentCard1.        sortedCards add: currentCard2.			        ((pile1 size > 1) and: [pile2 size > 1]) ifTrue: [ "if there are enough cards in the piles to continue the war"            sortedCards add: pile1 removeFirst.            sortedCards add: pile2 removeFirst. ].            (pile1 size = 0) ifTrue: [ "if there are not enough cards in the piles to continue the war"            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile2 addAll: sortedCards.            ^self winner: pile2 asArray].            (pile2 size = 0) ifTrue: [            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile1 addAll: sortedCards.            ^self winner: pile1 asArray].        currentCard1 := pile1 removeFirst.        currentCard2 := pile2 removeFirst].    (currentCard1 > currentCard2) "if the first card is greater than the second card, player 1 wins"	ifTrue: [        sortedCards add: currentCard1.        sortedCards add: currentCard2.        sortedCards := sortedCards sortBlock: [:a :b | a > b].        pile1 addAll: sortedCards.]	 ifFalse: [                    "if the second card is greater than the first card, player 2 wins"        sortedCards add: currentCard1.        sortedCards add: currentCard2.        sortedCards := sortedCards sortBlock: [:a :b | a > b].        pile2 addAll: sortedCards.].    (pile1 size = 0) ifTrue: [ ^self winner: pile2 asArray]. "if one of the piles is empty, the other player wins"    (pile2 size = 0) ifTrue: [ ^self winner: pile1 asArray].].! !----SNAPSHOT----2023-03-04T19:18:27.225-05:00 finalWar.image priorSource: 66086!----QUIT----2023-03-04T19:18:31.242-05:00 finalWar.image priorSource: 82759!!War class methodsFor: 'as yet unclassified' stamp: 'Anonymous 3/16/2023 10:24' prior: 33634439!deal: aDeck| pile1 pile2 | "pile1 and pile2 are the two piles of cards"pile1 := OrderedCollection new. pile2 := OrderedCollection new. aDeck withIndexDo: [:card :index | "deal the cards to the two piles"    (index odd) ifTrue: [           (card = 1) ifTrue: [ pile1 add: 14 ]  "ace is 14"                   ifFalse: [ pile1 add: card ] ]              ifFalse: [        (card = 1) ifTrue: [ pile2 add: 14 ]                   ifFalse: [ pile2 add: card ] ]].pile1 := pile1 reversed. "reverse the piles so that the first card is the top card"pile2 := pile2 reversed.[(pile1 size > 0) and: [pile2 size > 0]] whileTrue: [      |currentCard1 currentCard2 sortedCards|    sortedCards := SortedCollection new. "cards that are removed from the piles are added"    currentCard1 := pile1 removeFirst.    currentCard2 := pile2 removeFirst.	Transcript show: 'pile1: '; show: pile1 asArray; cr.	Transcript show: 'pile2: ';show: pile2 asArray; cr; cr.    [currentCard1 = currentCard2] whileTrue: [ "war occurs when the two cards are equal"        sortedCards add: currentCard1.        sortedCards add: currentCard2.			        ((pile1 size > 1) and: [pile2 size > 1]) ifTrue: [ "if there are enough cards in the piles to continue the war"            sortedCards add: pile1 removeFirst.            sortedCards add: pile2 removeFirst. ].            (pile1 size = 0) ifTrue: [ "if there are not enough cards in the piles to continue the war"            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile2 addAll: sortedCards.            ^self winner: pile2 asArray].            (pile2 size = 0) ifTrue: [            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile1 addAll: sortedCards.            ^self winner: pile1 asArray].        currentCard1 := pile1 removeFirst.        currentCard2 := pile2 removeFirst].    (currentCard1 > currentCard2) "if the first card is greater than the second card, player 1 wins"	ifTrue: [        sortedCards add: currentCard1.        sortedCards add: currentCard2.        sortedCards := sortedCards sortBlock: [:a :b | a > b].        pile1 addAll: sortedCards.]	 ifFalse: [                    "if the second card is greater than the first card, player 2 wins"        sortedCards add: currentCard1.        sortedCards add: currentCard2.        sortedCards := sortedCards sortBlock: [:a :b | a > b].        pile2 addAll: sortedCards.].    (pile1 size = 0) ifTrue: [ ^self winner: pile2 asArray]. "if one of the piles is empty, the other player wins"    (pile2 size = 0) ifTrue: [ ^self winner: pile1 asArray].].! !!War class methodsFor: 'as yet unclassified' stamp: 'Anonymous 3/16/2023 10:25' prior: 33637449!deal: aDeck| pile1 pile2 | "pile1 and pile2 are the two piles of cards"pile1 := OrderedCollection new. pile2 := OrderedCollection new. aDeck withIndexDo: [:card :index | "deal the cards to the two piles"    (index odd) ifTrue: [           (card = 1) ifTrue: [ pile1 add: 14 ]  "ace is 14"                   ifFalse: [ pile1 add: card ] ]              ifFalse: [        (card = 1) ifTrue: [ pile2 add: 14 ]                   ifFalse: [ pile2 add: card ] ]].pile1 := pile1 reversed. "reverse the piles so that the first card is the top card"pile2 := pile2 reversed.[(pile1 size > 0) and: [pile2 size > 0]] whileTrue: [      |currentCard1 currentCard2 sortedCards|    sortedCards := SortedCollection new. "cards that are removed from the piles are added"    currentCard1 := pile1 removeFirst.    currentCard2 := pile2 removeFirst.    [currentCard1 = currentCard2] whileTrue: [ "war occurs when the two cards are equal"        sortedCards add: currentCard1.        sortedCards add: currentCard2.			        ((pile1 size > 1) and: [pile2 size > 1]) ifTrue: [ "if there are enough cards in the piles to continue the war"            sortedCards add: pile1 removeFirst.            sortedCards add: pile2 removeFirst. ].            (pile1 size = 0) ifTrue: [ "if there are not enough cards in the piles to continue the war"            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile2 addAll: sortedCards.            ^self winner: pile2 asArray].            (pile2 size = 0) ifTrue: [            sortedCards := sortedCards sortBlock: [:a :b | a > b].            pile1 addAll: sortedCards.            ^self winner: pile1 asArray].        currentCard1 := pile1 removeFirst.        currentCard2 := pile2 removeFirst].    (currentCard1 > currentCard2) "if the first card is greater than the second card, player 1 wins"	ifTrue: [        sortedCards add: currentCard1.        sortedCards add: currentCard2.        sortedCards := sortedCards sortBlock: [:a :b | a > b].        pile1 addAll: sortedCards.]	 ifFalse: [                    "if the second card is greater than the first card, player 2 wins"        sortedCards add: currentCard1.        sortedCards add: currentCard2.        sortedCards := sortedCards sortBlock: [:a :b | a > b].        pile2 addAll: sortedCards.].    (pile1 size = 0) ifTrue: [ ^self winner: pile2 asArray]. "if one of the piles is empty, the other player wins"    (pile2 size = 0) ifTrue: [ ^self winner: pile1 asArray].].! !----SNAPSHOT----2023-03-16T10:26:04.542-04:00 finalWar.image priorSource: 82841!----QUIT----2023-03-16T10:54:25.856-04:00 finalWar.image priorSource: 88256!----QUIT----2023-03-24T12:46:36.098-04:00 finalWar.image priorSource: 88338!----QUIT/NOSAVE----2023-04-01T11:22:04.308-04:00 finalWar.image priorSource: 88416!----QUIT/NOSAVE----2023-04-09T15:38:32.241-04:00 finalWar.image priorSource: 88416!